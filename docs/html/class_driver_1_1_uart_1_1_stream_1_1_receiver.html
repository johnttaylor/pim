<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "https://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.8.18"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>PIM: Driver::Uart::Stream::Receiver Class Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td id="projectlogo"><img alt="Logo" src="logo2.gif"/></td>
  <td id="projectalign" style="padding-left: 0.5em;">
   <div id="projectname">PIM
   </div>
   <div id="projectbrief">Patterns in the Machine: Thermostat Example</div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.8.18 -->
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
$(function() {
  initMenu('',false,false,'search.php','Search');
});
/* @license-end */</script>
<div id="main-nav"></div>
<div id="nav-path" class="navpath">
  <ul>
<li class="navelem"><a class="el" href="namespace_driver.html">Driver</a></li><li class="navelem"><a class="el" href="namespace_driver_1_1_uart.html">Uart</a></li><li class="navelem"><a class="el" href="namespace_driver_1_1_uart_1_1_stream.html">Stream</a></li><li class="navelem"><a class="el" href="class_driver_1_1_uart_1_1_stream_1_1_receiver.html">Receiver</a></li>  </ul>
</div>
</div><!-- top -->
<div class="header">
  <div class="summary">
<a href="class_driver_1_1_uart_1_1_stream_1_1_receiver-members.html">List of all members</a> &#124;
<a href="#pub-methods">Public Member Functions</a> &#124;
<a href="#pro-attribs">Protected Attributes</a>  </div>
  <div class="headertitle">
<div class="title">Driver::Uart::Stream::Receiver Class Reference</div>  </div>
</div><!--header-->
<div class="contents">

<p>This concrete class implements a blocking Receive <a class="el" href="namespace_driver_1_1_uart_1_1_stream.html">Stream</a> UART driver.  
 <a href="class_driver_1_1_uart_1_1_stream_1_1_receiver.html#details">More...</a></p>
<a name="details" id="details"></a><h2 class="groupheader">Detailed Description</h2>
<div class="textblock"><p>This concrete class implements a blocking Receive <a class="el" href="namespace_driver_1_1_uart_1_1_stream.html">Stream</a> UART driver. </p>
<p>What does 'blocking Transmit <a class="el" href="namespace_driver_1_1_uart_1_1_stream.html">Stream</a>' mean? 'Blocking' means that the calling thread will block until at least one new byte has been received. '<a class="el" href="namespace_driver_1_1_uart_1_1_stream.html">Stream</a>' means that data is received as a continual stream of bytes, i.e. the data is NOT broken down into frames, packets, etc. (think C stdin stream).</p>
<p>This driver ASSUMES that at most there is only ONE client attempt to use the driver at any given time. It is okay to call the <a class="el" href="class_driver_1_1_uart_1_1_stream_1_1_receiver.html#a26e773e513e4428f67af561a73866545" title="This method starts/enables the driver.">start()</a>, <a class="el" href="class_driver_1_1_uart_1_1_stream_1_1_receiver.html#adfef6dfb32abd3240fc05130da2c064c" title="This method will stop/disable the driver.">stop()</a>, <a class="el" href="class_driver_1_1_uart_1_1_stream_1_1_receiver.html#af1ab13b835d04ce6a8f50299e2d30ef2" title="Receives at most the specified maximum number of bytes.">read()</a> from different threads - but the calls CANNOT be concurrent. It is the application's responsibility to provide additional thread-safety/concurrence protection. </p>
</div>
<p><code>#include &lt;<a class="el" href="_receiver_8h_source.html">Receiver.h</a>&gt;</code></p>
<div id="dynsection-0" onclick="return toggleVisibility(this)" class="dynheader closed" style="cursor:pointer;">
  <img id="dynsection-0-trigger" src="closed.png" alt="+"/> Collaboration diagram for Driver::Uart::Stream::Receiver:</div>
<div id="dynsection-0-summary" class="dynsummary" style="display:block;">
</div>
<div id="dynsection-0-content" class="dyncontent" style="display:none;">
<div class="center"><iframe scrolling="no" frameborder="0" src="class_driver_1_1_uart_1_1_stream_1_1_receiver__coll__graph.svg" width="360" height="336"><p><b>This browser is not able to show SVG: try Firefox, Chrome, Safari, or Opera instead.</b></p></iframe>
</div>
<center><span class="legend">[<a href="graph_legend.html">legend</a>]</span></center></div>
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pub-methods"></a>
Public Member Functions</h2></td></tr>
<tr class="memitem:ad34d4a7080305b695506ff9d2d273adf"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_driver_1_1_uart_1_1_stream_1_1_receiver.html#ad34d4a7080305b695506ff9d2d273adf">Receiver</a> (<a class="el" href="_driver_2_uart_2_hal_8h.html#a5f535f0949931d4b9b624b0e0fe300cf">Driver_Uart_Hal_T</a> uartHdl, unsigned bufSize, uint8_t bufMem[]) noexcept</td></tr>
<tr class="memdesc:ad34d4a7080305b695506ff9d2d273adf"><td class="mdescLeft">&#160;</td><td class="mdescRight">Constructor.  <a href="class_driver_1_1_uart_1_1_stream_1_1_receiver.html#ad34d4a7080305b695506ff9d2d273adf">More...</a><br /></td></tr>
<tr class="separator:ad34d4a7080305b695506ff9d2d273adf"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a26e773e513e4428f67af561a73866545"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_driver_1_1_uart_1_1_stream_1_1_receiver.html#a26e773e513e4428f67af561a73866545">start</a> (void) noexcept</td></tr>
<tr class="memdesc:a26e773e513e4428f67af561a73866545"><td class="mdescLeft">&#160;</td><td class="mdescRight">This method starts/enables the driver.  <a href="class_driver_1_1_uart_1_1_stream_1_1_receiver.html#a26e773e513e4428f67af561a73866545">More...</a><br /></td></tr>
<tr class="separator:a26e773e513e4428f67af561a73866545"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:adfef6dfb32abd3240fc05130da2c064c"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_driver_1_1_uart_1_1_stream_1_1_receiver.html#adfef6dfb32abd3240fc05130da2c064c">stop</a> (void) noexcept</td></tr>
<tr class="memdesc:adfef6dfb32abd3240fc05130da2c064c"><td class="mdescLeft">&#160;</td><td class="mdescRight">This method will stop/disable the driver.  <a href="class_driver_1_1_uart_1_1_stream_1_1_receiver.html#adfef6dfb32abd3240fc05130da2c064c">More...</a><br /></td></tr>
<tr class="separator:adfef6dfb32abd3240fc05130da2c064c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af1ab13b835d04ce6a8f50299e2d30ef2"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_driver_1_1_uart_1_1_stream_1_1_receiver.html#af1ab13b835d04ce6a8f50299e2d30ef2">read</a> (void *data, size_t maxBytes, size_t &amp;numBytesRx) noexcept</td></tr>
<tr class="memdesc:af1ab13b835d04ce6a8f50299e2d30ef2"><td class="mdescLeft">&#160;</td><td class="mdescRight">Receives at most the specified maximum number of bytes.  <a href="class_driver_1_1_uart_1_1_stream_1_1_receiver.html#af1ab13b835d04ce6a8f50299e2d30ef2">More...</a><br /></td></tr>
<tr class="separator:af1ab13b835d04ce6a8f50299e2d30ef2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a06086edf7ae767750c66385f639190d3"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_driver_1_1_uart_1_1_stream_1_1_receiver.html#a06086edf7ae767750c66385f639190d3">available</a> (void) const noexcept</td></tr>
<tr class="memdesc:a06086edf7ae767750c66385f639190d3"><td class="mdescLeft">&#160;</td><td class="mdescRight">This method returns true if at least one byte is available in the inbound buffer.  <a href="class_driver_1_1_uart_1_1_stream_1_1_receiver.html#a06086edf7ae767750c66385f639190d3">More...</a><br /></td></tr>
<tr class="separator:a06086edf7ae767750c66385f639190d3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac7c296080e46f69f744505215df8bf7c"><td class="memItemLeft" align="right" valign="top">size_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_driver_1_1_uart_1_1_stream_1_1_receiver.html#ac7c296080e46f69f744505215df8bf7c">getFramingErrorsCount</a> (bool clearCount=true) noexcept</td></tr>
<tr class="memdesc:ac7c296080e46f69f744505215df8bf7c"><td class="mdescLeft">&#160;</td><td class="mdescRight">This method returns and optionally clears the driver's framing error counter.  <a href="class_driver_1_1_uart_1_1_stream_1_1_receiver.html#ac7c296080e46f69f744505215df8bf7c">More...</a><br /></td></tr>
<tr class="separator:ac7c296080e46f69f744505215df8bf7c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afe86282629bfbc03c077df6745eb4632"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_driver_1_1_uart_1_1_stream_1_1_receiver.html#afe86282629bfbc03c077df6745eb4632">su_rxDataAndErrorIsr_</a> (void) noexcept</td></tr>
<tr class="memdesc:afe86282629bfbc03c077df6745eb4632"><td class="mdescLeft">&#160;</td><td class="mdescRight">This is a quasi-private method that the application should NOT call.  <a href="class_driver_1_1_uart_1_1_stream_1_1_receiver.html#afe86282629bfbc03c077df6745eb4632">More...</a><br /></td></tr>
<tr class="separator:afe86282629bfbc03c077df6745eb4632"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pro-attribs"></a>
Protected Attributes</h2></td></tr>
<tr class="memitem:adc33cde713078efbd4b430671272bde3"><td class="memItemLeft" align="right" valign="top"><a class="el" href="_driver_2_uart_2_hal_8h.html#a5f535f0949931d4b9b624b0e0fe300cf">Driver_Uart_Hal_T</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_driver_1_1_uart_1_1_stream_1_1_receiver.html#adc33cde713078efbd4b430671272bde3">m_uartHdl</a></td></tr>
<tr class="memdesc:adc33cde713078efbd4b430671272bde3"><td class="mdescLeft">&#160;</td><td class="mdescRight">Handle to my low level hardware.  <a href="class_driver_1_1_uart_1_1_stream_1_1_receiver.html#adc33cde713078efbd4b430671272bde3">More...</a><br /></td></tr>
<tr class="separator:adc33cde713078efbd4b430671272bde3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a38af2de7ec76676ea1cc3f975f100d13"><td class="memItemLeft" align="right" valign="top"><a class="el" href="class_cpl_1_1_system_1_1_thread.html">Cpl::System::Thread</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_driver_1_1_uart_1_1_stream_1_1_receiver.html#a38af2de7ec76676ea1cc3f975f100d13">m_waiterPtr</a></td></tr>
<tr class="memdesc:a38af2de7ec76676ea1cc3f975f100d13"><td class="mdescLeft">&#160;</td><td class="mdescRight">Handle of the blocked client thread (if there is one)  <a href="class_driver_1_1_uart_1_1_stream_1_1_receiver.html#a38af2de7ec76676ea1cc3f975f100d13">More...</a><br /></td></tr>
<tr class="separator:a38af2de7ec76676ea1cc3f975f100d13"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa19937b349147a4b2dbcf0d3729342e2"><td class="memItemLeft" align="right" valign="top">size_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_driver_1_1_uart_1_1_stream_1_1_receiver.html#aa19937b349147a4b2dbcf0d3729342e2">m_errCount</a></td></tr>
<tr class="memdesc:aa19937b349147a4b2dbcf0d3729342e2"><td class="mdescLeft">&#160;</td><td class="mdescRight">A Receive error was encountered.  <a href="class_driver_1_1_uart_1_1_stream_1_1_receiver.html#aa19937b349147a4b2dbcf0d3729342e2">More...</a><br /></td></tr>
<tr class="separator:aa19937b349147a4b2dbcf0d3729342e2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac862ea294fa0e9e08accf843a0225fb8"><td class="memItemLeft" align="right" valign="top"><a class="el" href="class_cpl_1_1_container_1_1_ring_buffer.html">Cpl::Container::RingBuffer</a>&lt; uint8_t &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_driver_1_1_uart_1_1_stream_1_1_receiver.html#ac862ea294fa0e9e08accf843a0225fb8">m_buffer</a></td></tr>
<tr class="memdesc:ac862ea294fa0e9e08accf843a0225fb8"><td class="mdescLeft">&#160;</td><td class="mdescRight">Transmit buffer.  <a href="class_driver_1_1_uart_1_1_stream_1_1_receiver.html#ac862ea294fa0e9e08accf843a0225fb8">More...</a><br /></td></tr>
<tr class="separator:ac862ea294fa0e9e08accf843a0225fb8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a14c01bf1c6fd0924a8f0264ab378ffe0"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_driver_1_1_uart_1_1_stream_1_1_receiver.html#a14c01bf1c6fd0924a8f0264ab378ffe0">m_started</a></td></tr>
<tr class="memdesc:a14c01bf1c6fd0924a8f0264ab378ffe0"><td class="mdescLeft">&#160;</td><td class="mdescRight">Started state of the driver.  <a href="class_driver_1_1_uart_1_1_stream_1_1_receiver.html#a14c01bf1c6fd0924a8f0264ab378ffe0">More...</a><br /></td></tr>
<tr class="separator:a14c01bf1c6fd0924a8f0264ab378ffe0"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<h2 class="groupheader">Constructor &amp; Destructor Documentation</h2>
<a id="ad34d4a7080305b695506ff9d2d273adf"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad34d4a7080305b695506ff9d2d273adf">&#9670;&nbsp;</a></span>Receiver()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">Driver::Uart::Stream::Receiver::Receiver </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="_driver_2_uart_2_hal_8h.html#a5f535f0949931d4b9b624b0e0fe300cf">Driver_Uart_Hal_T</a>&#160;</td>
          <td class="paramname"><em>uartHdl</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned&#160;</td>
          <td class="paramname"><em>bufSize</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint8_t&#160;</td>
          <td class="paramname"><em>bufMem</em>[]&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Constructor. </p>
<p>Note: The driver does not begin operating until <a class="el" href="class_driver_1_1_uart_1_1_stream_1_1_receiver.html#a26e773e513e4428f67af561a73866545" title="This method starts/enables the driver.">start()</a> is called.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">uartHdl</td><td>The HAL layer UART Handle. The application is required to initialize the low level UART before starting this driver. </td></tr>
    <tr><td class="paramname">bufSize</td><td>The number of bytes in the supplied receive buffer. </td></tr>
    <tr><td class="paramname">bufMem</td><td>Array of bytes for the receive/inbound buffer. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<h2 class="groupheader">Member Function Documentation</h2>
<a id="a06086edf7ae767750c66385f639190d3"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a06086edf7ae767750c66385f639190d3">&#9670;&nbsp;</a></span>available()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool Driver::Uart::Stream::Receiver::available </td>
          <td>(</td>
          <td class="paramtype">void&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>This method returns true if at least one byte is available in the inbound buffer. </p>

</div>
</div>
<a id="ac7c296080e46f69f744505215df8bf7c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac7c296080e46f69f744505215df8bf7c">&#9670;&nbsp;</a></span>getFramingErrorsCount()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">size_t Driver::Uart::Stream::Receiver::getFramingErrorsCount </td>
          <td>(</td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>clearCount</em> = <code>true</code></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>This method returns and optionally clears the driver's framing error counter. </p>

</div>
</div>
<a id="af1ab13b835d04ce6a8f50299e2d30ef2"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af1ab13b835d04ce6a8f50299e2d30ef2">&#9670;&nbsp;</a></span>read()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool Driver::Uart::Stream::Receiver::read </td>
          <td>(</td>
          <td class="paramtype">void *&#160;</td>
          <td class="paramname"><em>data</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>maxBytes</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t &amp;&#160;</td>
          <td class="paramname"><em>numBytesRx</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Receives at most the specified maximum number of bytes. </p>
<p>The actual number of bytes received is returned via 'numBytesRx'. The method does not return until at least one byte is available in the inbound buffer. The method returns true if successful; else false is returned.</p>
<p>NOTE: UART Framing errors are silents discarded, i.e. an incoming byte that is received with an associated framing error is NOT put into the inbound buffer. A free running counter is maintain of the number of framing errors encountered. </p>

</div>
</div>
<a id="a26e773e513e4428f67af561a73866545"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a26e773e513e4428f67af561a73866545">&#9670;&nbsp;</a></span>start()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void Driver::Uart::Stream::Receiver::start </td>
          <td>(</td>
          <td class="paramtype">void&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>This method starts/enables the driver. </p>
<p>Note: The application is RESPONSIBLE for performing the low level initialization (Baud Rate, framing, etc.) of the UART BEFORE this method is called. For the application to change the Baud rate, framing, etc - it must first stop the driver and then restart it. </p>

</div>
</div>
<a id="adfef6dfb32abd3240fc05130da2c064c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#adfef6dfb32abd3240fc05130da2c064c">&#9670;&nbsp;</a></span>stop()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void Driver::Uart::Stream::Receiver::stop </td>
          <td>(</td>
          <td class="paramtype">void&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>This method will stop/disable the driver. </p>
<p>The driver can be restarted by call <a class="el" href="class_driver_1_1_uart_1_1_stream_1_1_receiver.html#a26e773e513e4428f67af561a73866545" title="This method starts/enables the driver.">start()</a> again. The state of the contents of the inbound buffer and the byte(s) 'incoming' when the driver is stop is undetermined. </p>

</div>
</div>
<a id="afe86282629bfbc03c077df6745eb4632"></a>
<h2 class="memtitle"><span class="permalink"><a href="#afe86282629bfbc03c077df6745eb4632">&#9670;&nbsp;</a></span>su_rxDataAndErrorIsr_()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">int Driver::Uart::Stream::Receiver::su_rxDataAndErrorIsr_ </td>
          <td>(</td>
          <td class="paramtype">void&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>This is a quasi-private method that the application should NOT call. </p>
<p>The method SHOULD only be called by the interrupt service routine (ISR) for the 'RX-Data-Available interrupt for the UART identified by the 'uartHdl' supplied in the constructor. This requires that a reference (at a minimum) to the driver instance be a global variable.</p>
<p>The method returns the result of signaling waiter (i.e. return code from su_signal()), or zero if no waiter was signaled. </p>

</div>
</div>
<h2 class="groupheader">Member Data Documentation</h2>
<a id="ac862ea294fa0e9e08accf843a0225fb8"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac862ea294fa0e9e08accf843a0225fb8">&#9670;&nbsp;</a></span>m_buffer</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="class_cpl_1_1_container_1_1_ring_buffer.html">Cpl::Container::RingBuffer</a>&lt;uint8_t&gt; Driver::Uart::Stream::Receiver::m_buffer</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Transmit buffer. </p>

</div>
</div>
<a id="aa19937b349147a4b2dbcf0d3729342e2"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa19937b349147a4b2dbcf0d3729342e2">&#9670;&nbsp;</a></span>m_errCount</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">size_t Driver::Uart::Stream::Receiver::m_errCount</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>A Receive error was encountered. </p>

</div>
</div>
<a id="a14c01bf1c6fd0924a8f0264ab378ffe0"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a14c01bf1c6fd0924a8f0264ab378ffe0">&#9670;&nbsp;</a></span>m_started</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool Driver::Uart::Stream::Receiver::m_started</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Started state of the driver. </p>

</div>
</div>
<a id="adc33cde713078efbd4b430671272bde3"></a>
<h2 class="memtitle"><span class="permalink"><a href="#adc33cde713078efbd4b430671272bde3">&#9670;&nbsp;</a></span>m_uartHdl</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="_driver_2_uart_2_hal_8h.html#a5f535f0949931d4b9b624b0e0fe300cf">Driver_Uart_Hal_T</a> Driver::Uart::Stream::Receiver::m_uartHdl</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Handle to my low level hardware. </p>

</div>
</div>
<a id="a38af2de7ec76676ea1cc3f975f100d13"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a38af2de7ec76676ea1cc3f975f100d13">&#9670;&nbsp;</a></span>m_waiterPtr</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="class_cpl_1_1_system_1_1_thread.html">Cpl::System::Thread</a>* Driver::Uart::Stream::Receiver::m_waiterPtr</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Handle of the blocked client thread (if there is one) </p>

</div>
</div>
<hr/>The documentation for this class was generated from the following file:<ul>
<li>Driver/Uart/Stream/<a class="el" href="_receiver_8h_source.html">Receiver.h</a></li>
</ul>
</div><!-- contents -->
<!-- start footer part -->
<hr class="footer"/><address class="footer"><small>
Generated on Thu Dec 10 2020 16:32:58 for PIM by &#160;<a href="http://www.doxygen.org/index.html">
<img class="footer" src="doxygen.png" alt="doxygen"/>
</a> 1.8.18
</small></address>
</body>
</html>
