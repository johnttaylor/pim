<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "https://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml" lang="en-US">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=11"/>
<meta name="generator" content="Doxygen 1.10.0"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>Patterns in the Machine: Cpl::Io::Serial::ST::M32F4::StreamDriver Class Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr id="projectrow">
  <td id="projectlogo"><img alt="Logo" src="logo2.gif"/></td>
  <td id="projectalign">
   <div id="projectname">Patterns in the Machine<span id="projectnumber">&#160;$$$PROJECT_NUMBER$$$</span>
   </div>
   <div id="projectbrief">Embedded C++ Class Library</div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.10.0 -->
  <div id="navrow1" class="tabs">
    <ul class="tablist">
      <li><a href="index.html"><span>Main&#160;Page</span></a></li>
      <li><a href="namespaces.html"><span>Namespaces</span></a></li>
      <li class="current"><a href="annotated.html"><span>Components</span></a></li>
      <li><a href="files.html"><span>Files</span></a></li>
    </ul>
  </div>
  <div id="navrow2" class="tabs2">
    <ul class="tablist">
      <li><a href="annotated.html"><span>Components&#160;List</span></a></li>
      <li><a href="classes.html"><span>Class&#160;Index</span></a></li>
      <li><a href="inherits.html"><span>Class&#160;Hierarchy</span></a></li>
      <li><a href="functions.html"><span>Class&#160;Members</span></a></li>
    </ul>
  </div>
<div id="nav-path" class="navpath">
  <ul>
<li class="navelem"><a class="el" href="namespace_cpl.html">Cpl</a></li><li class="navelem"><a class="el" href="namespace_cpl_1_1_io.html">Io</a></li><li class="navelem"><a class="el" href="namespace_cpl_1_1_io_1_1_serial.html">Serial</a></li><li class="navelem"><a class="el" href="namespace_cpl_1_1_io_1_1_serial_1_1_s_t.html">ST</a></li><li class="navelem"><a class="el" href="namespace_cpl_1_1_io_1_1_serial_1_1_s_t_1_1_m32_f4.html">M32F4</a></li><li class="navelem"><a class="el" href="class_cpl_1_1_io_1_1_serial_1_1_s_t_1_1_m32_f4_1_1_stream_driver.html">StreamDriver</a></li>  </ul>
</div>
</div><!-- top -->
<div class="header">
  <div class="summary">
<a href="class_cpl_1_1_io_1_1_serial_1_1_s_t_1_1_m32_f4_1_1_stream_driver-members.html">List of all members</a> &#124;
<a href="#nested-classes">Classes</a> &#124;
<a href="#pub-methods">Public Member Functions</a> &#124;
<a href="#pro-methods">Protected Member Functions</a> &#124;
<a href="#pro-static-methods">Static Protected Member Functions</a> &#124;
<a href="#pro-attribs">Protected Attributes</a> &#124;
<a href="#pro-static-attribs">Static Protected Attributes</a>  </div>
  <div class="headertitle"><div class="title">Cpl::Io::Serial::ST::M32F4::StreamDriver Class Reference</div></div>
</div><!--header-->
<div class="contents">

<p>This concrete class implements a non-busy-wait blocking Transmit/Receive Stream UART driver with a SOFTWARE FIFO.  
 <a href="#details">More...</a></p>
<a name="details" id="details"></a><h2 class="groupheader">Detailed Description</h2>
<div class="textblock"><p>This concrete class implements a non-busy-wait blocking Transmit/Receive Stream UART driver with a SOFTWARE FIFO. </p>
<p>This driver ASSUMES that at most there is only ONE client (per TX/RX operations) attempting to use the driver at any given time. The TX and RX clients can be different clients/threads.</p>
<p>It is okay to call the <a class="el" href="#a6d41e282f8e39822a7dee2b596dcde92" title="This method starts/enables the driver.">start()</a>, <a class="el" href="#ad05e1441b71c7f70c3c97573d63352a5" title="This method will stop/disable the driver.">stop()</a>, <a class="el" href="#a2b2c14e184735307f7fda1f14b388951" title="Transmits the specified number of bytes.">write()</a> from different threads - but the calls CANNOT be concurrent. It is the application's responsibility to provide additional thread-safety/concurrence protection. </p>
</div>
<p><code>#include &lt;<a class="el" href="_stream_driver_8h_source.html">StreamDriver.h</a>&gt;</code></p>
<div class="dynheader">
Collaboration diagram for Cpl::Io::Serial::ST::M32F4::StreamDriver:</div>
<div class="dyncontent">
<div class="center"><iframe scrolling="no" frameborder="0" src="class_cpl_1_1_io_1_1_serial_1_1_s_t_1_1_m32_f4_1_1_stream_driver__coll__graph.svg" width="1218" height="115"><p><b>This browser is not able to show SVG: try Firefox, Chrome, Safari, or Opera instead.</b></p></iframe></div>
<center><span class="legend">[<a href="graph_legend.html">legend</a>]</span></center></div>
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a id="nested-classes" name="nested-classes"></a>
Classes</h2></td></tr>
<tr class="memitem:struct_cpl_1_1_io_1_1_serial_1_1_s_t_1_1_m32_f4_1_1_stream_driver_1_1_hal_mapping___t" id="r_struct_cpl_1_1_io_1_1_serial_1_1_s_t_1_1_m32_f4_1_1_stream_driver_1_1_hal_mapping___t"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#struct_cpl_1_1_io_1_1_serial_1_1_s_t_1_1_m32_f4_1_1_stream_driver_1_1_hal_mapping___t">HalMapping_T</a></td></tr>
<tr class="memdesc:struct_cpl_1_1_io_1_1_serial_1_1_s_t_1_1_m32_f4_1_1_stream_driver_1_1_hal_mapping___t"><td class="mdescLeft">&#160;</td><td class="mdescRight">Used to map a HAL UART Handle to an instance of this class.  <a href="#struct_cpl_1_1_io_1_1_serial_1_1_s_t_1_1_m32_f4_1_1_stream_driver_1_1_hal_mapping___t">More...</a><br /></td></tr>
<tr class="separator:struct_cpl_1_1_io_1_1_serial_1_1_s_t_1_1_m32_f4_1_1_stream_driver_1_1_hal_mapping___t"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a id="pub-methods" name="pub-methods"></a>
Public Member Functions</h2></td></tr>
<tr class="memitem:a591b7d6ab833d1fbaa2118d758a9eae3" id="r_a591b7d6ab833d1fbaa2118d758a9eae3"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a591b7d6ab833d1fbaa2118d758a9eae3">StreamDriver</a> (<a class="el" href="class_cpl_1_1_container_1_1_ring_buffer.html">Cpl::Container::RingBuffer</a>&lt; uint8_t &gt; &amp;txBuffer, <a class="el" href="class_cpl_1_1_container_1_1_ring_buffer.html">Cpl::Container::RingBuffer</a>&lt; uint8_t &gt; &amp;rxBuffer) noexcept</td></tr>
<tr class="memdesc:a591b7d6ab833d1fbaa2118d758a9eae3"><td class="mdescLeft">&#160;</td><td class="mdescRight">Constructor.  <br /></td></tr>
<tr class="separator:a591b7d6ab833d1fbaa2118d758a9eae3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6d41e282f8e39822a7dee2b596dcde92" id="r_a6d41e282f8e39822a7dee2b596dcde92"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a6d41e282f8e39822a7dee2b596dcde92">start</a> (IRQn_Type uartIrqNum, UART_HandleTypeDef *uartHdl) noexcept</td></tr>
<tr class="memdesc:a6d41e282f8e39822a7dee2b596dcde92"><td class="mdescLeft">&#160;</td><td class="mdescRight">This method starts/enables the driver.  <br /></td></tr>
<tr class="separator:a6d41e282f8e39822a7dee2b596dcde92"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad05e1441b71c7f70c3c97573d63352a5" id="r_ad05e1441b71c7f70c3c97573d63352a5"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#ad05e1441b71c7f70c3c97573d63352a5">stop</a> (void) noexcept</td></tr>
<tr class="memdesc:ad05e1441b71c7f70c3c97573d63352a5"><td class="mdescLeft">&#160;</td><td class="mdescRight">This method will stop/disable the driver.  <br /></td></tr>
<tr class="separator:ad05e1441b71c7f70c3c97573d63352a5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2b2c14e184735307f7fda1f14b388951" id="r_a2b2c14e184735307f7fda1f14b388951"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a2b2c14e184735307f7fda1f14b388951">write</a> (const void *data, size_t numBytesToTx) noexcept</td></tr>
<tr class="memdesc:a2b2c14e184735307f7fda1f14b388951"><td class="mdescLeft">&#160;</td><td class="mdescRight">Transmits the specified number of bytes.  <br /></td></tr>
<tr class="separator:a2b2c14e184735307f7fda1f14b388951"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a591330952397130077b6b5a3f4ce37fd" id="r_a591330952397130077b6b5a3f4ce37fd"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a591330952397130077b6b5a3f4ce37fd">read</a> (void *data, int maxBytes, int &amp;numBytesRx) noexcept</td></tr>
<tr class="memdesc:a591330952397130077b6b5a3f4ce37fd"><td class="mdescLeft">&#160;</td><td class="mdescRight">Receives at most the specified maximum number of bytes.  <br /></td></tr>
<tr class="separator:a591330952397130077b6b5a3f4ce37fd"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0b26350d26503936239c893e2fc5b4fb" id="r_a0b26350d26503936239c893e2fc5b4fb"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a0b26350d26503936239c893e2fc5b4fb">available</a> (void) const noexcept</td></tr>
<tr class="memdesc:a0b26350d26503936239c893e2fc5b4fb"><td class="mdescLeft">&#160;</td><td class="mdescRight">This method returns true if at least one byte is available in the inbound buffer.  <br /></td></tr>
<tr class="separator:a0b26350d26503936239c893e2fc5b4fb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad43a63c3c5afbc6cf32a23abc26633f6" id="r_ad43a63c3c5afbc6cf32a23abc26633f6"><td class="memItemLeft" align="right" valign="top">size_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#ad43a63c3c5afbc6cf32a23abc26633f6">getRXErrorsCounts</a> (bool clearCount=true) noexcept</td></tr>
<tr class="memdesc:ad43a63c3c5afbc6cf32a23abc26633f6"><td class="mdescLeft">&#160;</td><td class="mdescRight">This method returns and optionally clears the driver's RX error counter.  <br /></td></tr>
<tr class="separator:ad43a63c3c5afbc6cf32a23abc26633f6"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a id="pro-methods" name="pro-methods"></a>
Protected Member Functions</h2></td></tr>
<tr class="memitem:a800f5ee1920b60559228dd6329869f83" id="r_a800f5ee1920b60559228dd6329869f83"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a800f5ee1920b60559228dd6329869f83">su_txDoneIsr</a> (void) noexcept</td></tr>
<tr class="memdesc:a800f5ee1920b60559228dd6329869f83"><td class="mdescLeft">&#160;</td><td class="mdescRight">This method SHOULD only be called when the HAL Transmit operation has completed (aka from the HAL_UART_TxCpltCallback() function).  <br /></td></tr>
<tr class="separator:a800f5ee1920b60559228dd6329869f83"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a97b3c47fb857aa9139efa54106c1c868" id="r_a97b3c47fb857aa9139efa54106c1c868"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a97b3c47fb857aa9139efa54106c1c868">su_rxDataAndErrorIsr</a> (uint16_t bytesReceived) noexcept</td></tr>
<tr class="memdesc:a97b3c47fb857aa9139efa54106c1c868"><td class="mdescLeft">&#160;</td><td class="mdescRight">The method SHOULD only be called when the HAL Receive operation has completed (aka from the HAL_UART_RxCpltCallback() or HAL_UART_ErrorCallback() functions).  <br /></td></tr>
<tr class="separator:a97b3c47fb857aa9139efa54106c1c868"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a id="pro-static-methods" name="pro-static-methods"></a>
Static Protected Member Functions</h2></td></tr>
<tr class="memitem:ae9b6792cf49a44b8dba31c8da65b8bda" id="r_ae9b6792cf49a44b8dba31c8da65b8bda"><td class="memItemLeft" align="right" valign="top">static void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#ae9b6792cf49a44b8dba31c8da65b8bda">su_txCompleteCallback</a> (UART_HandleTypeDef *huart) noexcept</td></tr>
<tr class="memdesc:ae9b6792cf49a44b8dba31c8da65b8bda"><td class="mdescLeft">&#160;</td><td class="mdescRight">Used to pre-process the HAL_UART_TxCpltCallback() call to the specific Driver instance.  <br /></td></tr>
<tr class="separator:ae9b6792cf49a44b8dba31c8da65b8bda"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a183cd63aece309d37d1f776398cdf125" id="r_a183cd63aece309d37d1f776398cdf125"><td class="memItemLeft" align="right" valign="top">static void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a183cd63aece309d37d1f776398cdf125">su_rxEventCompleteCallback</a> (UART_HandleTypeDef *huart, uint16_t bytesReceived) noexcept</td></tr>
<tr class="memdesc:a183cd63aece309d37d1f776398cdf125"><td class="mdescLeft">&#160;</td><td class="mdescRight">Used to pre-process the HAL_UARTEx_RxEventCallback() call to the specific Driver instance.  <br /></td></tr>
<tr class="separator:a183cd63aece309d37d1f776398cdf125"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:add76064190c0f2adc96582f8a0c0b6a6" id="r_add76064190c0f2adc96582f8a0c0b6a6"><td class="memItemLeft" align="right" valign="top">static void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#add76064190c0f2adc96582f8a0c0b6a6">su_rxErrorCompleteCallback</a> (UART_HandleTypeDef *huart) noexcept</td></tr>
<tr class="memdesc:add76064190c0f2adc96582f8a0c0b6a6"><td class="mdescLeft">&#160;</td><td class="mdescRight">Used to pre-process the HAL_UART_ErrorCallback() call to the specific Driver instance.  <br /></td></tr>
<tr class="separator:add76064190c0f2adc96582f8a0c0b6a6"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a id="pro-attribs" name="pro-attribs"></a>
Protected Attributes</h2></td></tr>
<tr class="memitem:a43e124b79a14027941a313f026a5c57b" id="r_a43e124b79a14027941a313f026a5c57b"><td class="memItemLeft" align="right" valign="top">UART_HandleTypeDef *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a43e124b79a14027941a313f026a5c57b">m_uartHdl</a></td></tr>
<tr class="memdesc:a43e124b79a14027941a313f026a5c57b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Handle to my low level hardware.  <br /></td></tr>
<tr class="separator:a43e124b79a14027941a313f026a5c57b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab04ecc14f69ce2b7eeb30016f45568dc" id="r_ab04ecc14f69ce2b7eeb30016f45568dc"><td class="memItemLeft" align="right" valign="top"><a class="el" href="class_cpl_1_1_system_1_1_thread.html">Cpl::System::Thread</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#ab04ecc14f69ce2b7eeb30016f45568dc">m_txWaiterPtr</a></td></tr>
<tr class="memdesc:ab04ecc14f69ce2b7eeb30016f45568dc"><td class="mdescLeft">&#160;</td><td class="mdescRight">Handle of the blocked TX client thread (if there is one)  <br /></td></tr>
<tr class="separator:ab04ecc14f69ce2b7eeb30016f45568dc"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1551e89e66b14f0796903b43e5454beb" id="r_a1551e89e66b14f0796903b43e5454beb"><td class="memItemLeft" align="right" valign="top"><a class="el" href="class_cpl_1_1_system_1_1_thread.html">Cpl::System::Thread</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a1551e89e66b14f0796903b43e5454beb">m_rxWaiterPtr</a></td></tr>
<tr class="memdesc:a1551e89e66b14f0796903b43e5454beb"><td class="mdescLeft">&#160;</td><td class="mdescRight">Handle of the blocked RX client thread (if there is one)  <br /></td></tr>
<tr class="separator:a1551e89e66b14f0796903b43e5454beb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a95a856e02b5dc595956926b6885b4aad" id="r_a95a856e02b5dc595956926b6885b4aad"><td class="memItemLeft" align="right" valign="top">IRQn_Type&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a95a856e02b5dc595956926b6885b4aad">m_uartIrqNum</a></td></tr>
<tr class="memdesc:a95a856e02b5dc595956926b6885b4aad"><td class="mdescLeft">&#160;</td><td class="mdescRight">IRQ number of the UART being used.  <br /></td></tr>
<tr class="separator:a95a856e02b5dc595956926b6885b4aad"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a927db7e8911217f37337814dfff1a172" id="r_a927db7e8911217f37337814dfff1a172"><td class="memItemLeft" align="right" valign="top"><a class="el" href="class_cpl_1_1_container_1_1_ring_buffer.html">Cpl::Container::RingBuffer</a>&lt; uint8_t &gt; &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a927db7e8911217f37337814dfff1a172">m_txBuffer</a></td></tr>
<tr class="memdesc:a927db7e8911217f37337814dfff1a172"><td class="mdescLeft">&#160;</td><td class="mdescRight">Transmit buffer.  <br /></td></tr>
<tr class="separator:a927db7e8911217f37337814dfff1a172"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab6ff4907169ae6caf126b1f6d05a7c7a" id="r_ab6ff4907169ae6caf126b1f6d05a7c7a"><td class="memItemLeft" align="right" valign="top"><a class="el" href="class_cpl_1_1_container_1_1_ring_buffer.html">Cpl::Container::RingBuffer</a>&lt; uint8_t &gt; &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#ab6ff4907169ae6caf126b1f6d05a7c7a">m_rxBuffer</a></td></tr>
<tr class="memdesc:ab6ff4907169ae6caf126b1f6d05a7c7a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Receive buffer.  <br /></td></tr>
<tr class="separator:ab6ff4907169ae6caf126b1f6d05a7c7a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0de5bde14fbaadad55d7c1c269057dc3" id="r_a0de5bde14fbaadad55d7c1c269057dc3"><td class="memItemLeft" align="right" valign="top">size_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a0de5bde14fbaadad55d7c1c269057dc3">m_errCount</a></td></tr>
<tr class="memdesc:a0de5bde14fbaadad55d7c1c269057dc3"><td class="mdescLeft">&#160;</td><td class="mdescRight">A Receive error was encountered.  <br /></td></tr>
<tr class="separator:a0de5bde14fbaadad55d7c1c269057dc3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aecfc02bf747b9a74d51f921aec96b59a" id="r_aecfc02bf747b9a74d51f921aec96b59a"><td class="memItemLeft" align="right" valign="top">unsigned&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#aecfc02bf747b9a74d51f921aec96b59a">m_txSize</a></td></tr>
<tr class="memdesc:aecfc02bf747b9a74d51f921aec96b59a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Number of bytes requested to be transmitted by the HAL.  <br /></td></tr>
<tr class="separator:aecfc02bf747b9a74d51f921aec96b59a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9192c3eb96de9739f5460877bfa38ff1" id="r_a9192c3eb96de9739f5460877bfa38ff1"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a9192c3eb96de9739f5460877bfa38ff1">m_rxActive</a></td></tr>
<tr class="memdesc:a9192c3eb96de9739f5460877bfa38ff1"><td class="mdescLeft">&#160;</td><td class="mdescRight">Receive state.  <br /></td></tr>
<tr class="separator:a9192c3eb96de9739f5460877bfa38ff1"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a id="pro-static-attribs" name="pro-static-attribs"></a>
Static Protected Attributes</h2></td></tr>
<tr class="memitem:a25a8858288dd9a1b21bfd7bcee22bfe2" id="r_a25a8858288dd9a1b21bfd7bcee22bfe2"><td class="memItemLeft" align="right" valign="top">static <a class="el" href="#struct_cpl_1_1_io_1_1_serial_1_1_s_t_1_1_m32_f4_1_1_stream_driver_1_1_hal_mapping___t">HalMapping_T</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a25a8858288dd9a1b21bfd7bcee22bfe2">m_mappings</a> [<a class="el" href="_stream_driver_8h.html#a9e309e31724673a4b66a68d9415cef40">OPTION_CPL_IO_SERIAL_ST_M32F4_MAX_UARTS</a>]</td></tr>
<tr class="memdesc:a25a8858288dd9a1b21bfd7bcee22bfe2"><td class="mdescLeft">&#160;</td><td class="mdescRight">Map the HAL UART to a transmitter instance.  <br /></td></tr>
<tr class="separator:a25a8858288dd9a1b21bfd7bcee22bfe2"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<hr/><h2 class="groupheader">Class Documentation</h2>
<a name="struct_cpl_1_1_io_1_1_serial_1_1_s_t_1_1_m32_f4_1_1_stream_driver_1_1_hal_mapping___t" id="struct_cpl_1_1_io_1_1_serial_1_1_s_t_1_1_m32_f4_1_1_stream_driver_1_1_hal_mapping___t"></a>
<h2 class="memtitle"><span class="permalink"><a href="#struct_cpl_1_1_io_1_1_serial_1_1_s_t_1_1_m32_f4_1_1_stream_driver_1_1_hal_mapping___t">&#9670;&#160;</a></span>Cpl::Io::Serial::ST::M32F4::StreamDriver::HalMapping_T</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">struct Cpl::Io::Serial::ST::M32F4::StreamDriver::HalMapping_T</td>
        </tr>
      </table>
</div><div class="memdoc">
<div class="textblock"><p>Used to map a HAL UART Handle to an instance of this class. </p>
</div><div class="dynheader">
Collaboration diagram for Cpl::Io::Serial::ST::M32F4::StreamDriver::HalMapping_T:</div>
<div class="dyncontent">
<div class="center"><iframe scrolling="no" frameborder="0" src="struct_cpl_1_1_io_1_1_serial_1_1_s_t_1_1_m32_f4_1_1_stream_driver_1_1_hal_mapping___t__coll__graph.svg" width="526" height="375"><p><b>This browser is not able to show SVG: try Firefox, Chrome, Safari, or Opera instead.</b></p></iframe></div>
<center><span class="legend">[<a href="graph_legend.html">legend</a>]</span></center></div>
<table class="fieldtable">
<tr><th colspan="3">Class Members</th></tr>
<tr><td class="fieldtype">
<a id="ad8fc61678b2ff4bb3d1356f5711a65de" name="ad8fc61678b2ff4bb3d1356f5711a65de"></a><a class="el" href="class_cpl_1_1_io_1_1_serial_1_1_s_t_1_1_m32_f4_1_1_stream_driver.html">StreamDriver</a> *</td>
<td class="fieldname">
driver</td>
<td class="fielddoc">
Associated CPL driver instance. </td></tr>
<tr><td class="fieldtype">
<a id="a90f4141808f2066bcffe017eef9a29c8" name="a90f4141808f2066bcffe017eef9a29c8"></a>UART_HandleTypeDef *</td>
<td class="fieldname">
halHandle</td>
<td class="fielddoc">
HAL Handle of the UART. </td></tr>
</table>

</div>
</div>
<h2 class="groupheader">Constructor &amp; Destructor Documentation</h2>
<a id="a591b7d6ab833d1fbaa2118d758a9eae3" name="a591b7d6ab833d1fbaa2118d758a9eae3"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a591b7d6ab833d1fbaa2118d758a9eae3">&#9670;&#160;</a></span>StreamDriver()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">Cpl::Io::Serial::ST::M32F4::StreamDriver::StreamDriver </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="class_cpl_1_1_container_1_1_ring_buffer.html">Cpl::Container::RingBuffer</a>&lt; uint8_t &gt; &amp;</td>          <td class="paramname"><span class="paramname"><em>txBuffer</em>, </span></td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="class_cpl_1_1_container_1_1_ring_buffer.html">Cpl::Container::RingBuffer</a>&lt; uint8_t &gt; &amp;</td>          <td class="paramname"><span class="paramname"><em>rxBuffer</em></span>&#160;)</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Constructor. </p>
<p>Note: The driver does not begin operating until <a class="el" href="#a6d41e282f8e39822a7dee2b596dcde92" title="This method starts/enables the driver.">start()</a> is called. </p>

</div>
</div>
<h2 class="groupheader">Member Function Documentation</h2>
<a id="a0b26350d26503936239c893e2fc5b4fb" name="a0b26350d26503936239c893e2fc5b4fb"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0b26350d26503936239c893e2fc5b4fb">&#9670;&#160;</a></span>available()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool Cpl::Io::Serial::ST::M32F4::StreamDriver::available </td>
          <td>(</td>
          <td class="paramtype">void</td>          <td class="paramname"><span class="paramname"></span></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>This method returns true if at least one byte is available in the inbound buffer. </p>

</div>
</div>
<a id="ad43a63c3c5afbc6cf32a23abc26633f6" name="ad43a63c3c5afbc6cf32a23abc26633f6"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad43a63c3c5afbc6cf32a23abc26633f6">&#9670;&#160;</a></span>getRXErrorsCounts()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">size_t Cpl::Io::Serial::ST::M32F4::StreamDriver::getRXErrorsCounts </td>
          <td>(</td>
          <td class="paramtype">bool</td>          <td class="paramname"><span class="paramname"><em>clearCount</em><span class="paramdefsep"> = </span><span class="paramdefval">true</span></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>This method returns and optionally clears the driver's RX error counter. </p>

</div>
</div>
<a id="a591330952397130077b6b5a3f4ce37fd" name="a591330952397130077b6b5a3f4ce37fd"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a591330952397130077b6b5a3f4ce37fd">&#9670;&#160;</a></span>read()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool Cpl::Io::Serial::ST::M32F4::StreamDriver::read </td>
          <td>(</td>
          <td class="paramtype">void *</td>          <td class="paramname"><span class="paramname"><em>data</em>, </span></td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int</td>          <td class="paramname"><span class="paramname"><em>maxBytes</em>, </span></td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int &amp;</td>          <td class="paramname"><span class="paramname"><em>numBytesRx</em></span>&#160;)</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Receives at most the specified maximum number of bytes. </p>
<p>The actual number of bytes received is returned via 'numBytesRx'. The method does not return until at least one byte is available in the inbound buffer. The method returns true if successful; else false is returned.</p>
<p>NOTE: UART Framing errors are silents discarded, i.e. an incoming byte that is received with an associated framing error is NOT put into the inbound buffer. A free running counter is maintain of the number of framing errors encountered. </p>

</div>
</div>
<a id="a6d41e282f8e39822a7dee2b596dcde92" name="a6d41e282f8e39822a7dee2b596dcde92"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6d41e282f8e39822a7dee2b596dcde92">&#9670;&#160;</a></span>start()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void Cpl::Io::Serial::ST::M32F4::StreamDriver::start </td>
          <td>(</td>
          <td class="paramtype">IRQn_Type</td>          <td class="paramname"><span class="paramname"><em>uartIrqNum</em>, </span></td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">UART_HandleTypeDef *</td>          <td class="paramname"><span class="paramname"><em>uartHdl</em></span>&#160;)</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>This method starts/enables the driver. </p>
<p>Note: The application is RESPONSIBLE for performing the low level initialization (Baud Rate, framing, etc.) of the UART BEFORE this method is called. For the application to change the Baud rate, framing, etc - it must first stop the driver and then restart it. </p>

</div>
</div>
<a id="ad05e1441b71c7f70c3c97573d63352a5" name="ad05e1441b71c7f70c3c97573d63352a5"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad05e1441b71c7f70c3c97573d63352a5">&#9670;&#160;</a></span>stop()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void Cpl::Io::Serial::ST::M32F4::StreamDriver::stop </td>
          <td>(</td>
          <td class="paramtype">void</td>          <td class="paramname"><span class="paramname"></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>This method will stop/disable the driver. </p>
<p>The driver can be restarted by call <a class="el" href="#a6d41e282f8e39822a7dee2b596dcde92" title="This method starts/enables the driver.">start()</a> again. The state of the contents of the outbound buffer and the byte(s) 'in transmit' when the driver is stop is undetermined. </p>

</div>
</div>
<a id="a97b3c47fb857aa9139efa54106c1c868" name="a97b3c47fb857aa9139efa54106c1c868"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a97b3c47fb857aa9139efa54106c1c868">&#9670;&#160;</a></span>su_rxDataAndErrorIsr()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void Cpl::Io::Serial::ST::M32F4::StreamDriver::su_rxDataAndErrorIsr </td>
          <td>(</td>
          <td class="paramtype">uint16_t</td>          <td class="paramname"><span class="paramname"><em>bytesReceived</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>The method SHOULD only be called when the HAL Receive operation has completed (aka from the HAL_UART_RxCpltCallback() or HAL_UART_ErrorCallback() functions). </p>
<p>This method executes in the context of interrupt service routine (ISR) </p>

</div>
</div>
<a id="add76064190c0f2adc96582f8a0c0b6a6" name="add76064190c0f2adc96582f8a0c0b6a6"></a>
<h2 class="memtitle"><span class="permalink"><a href="#add76064190c0f2adc96582f8a0c0b6a6">&#9670;&#160;</a></span>su_rxErrorCompleteCallback()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static void Cpl::Io::Serial::ST::M32F4::StreamDriver::su_rxErrorCompleteCallback </td>
          <td>(</td>
          <td class="paramtype">UART_HandleTypeDef *</td>          <td class="paramname"><span class="paramname"><em>huart</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span><span class="mlabel">protected</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Used to pre-process the HAL_UART_ErrorCallback() call to the specific Driver instance. </p>

</div>
</div>
<a id="a183cd63aece309d37d1f776398cdf125" name="a183cd63aece309d37d1f776398cdf125"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a183cd63aece309d37d1f776398cdf125">&#9670;&#160;</a></span>su_rxEventCompleteCallback()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static void Cpl::Io::Serial::ST::M32F4::StreamDriver::su_rxEventCompleteCallback </td>
          <td>(</td>
          <td class="paramtype">UART_HandleTypeDef *</td>          <td class="paramname"><span class="paramname"><em>huart</em>, </span></td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint16_t</td>          <td class="paramname"><span class="paramname"><em>bytesReceived</em></span>&#160;)</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span><span class="mlabel">protected</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Used to pre-process the HAL_UARTEx_RxEventCallback() call to the specific Driver instance. </p>

</div>
</div>
<a id="ae9b6792cf49a44b8dba31c8da65b8bda" name="ae9b6792cf49a44b8dba31c8da65b8bda"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae9b6792cf49a44b8dba31c8da65b8bda">&#9670;&#160;</a></span>su_txCompleteCallback()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static void Cpl::Io::Serial::ST::M32F4::StreamDriver::su_txCompleteCallback </td>
          <td>(</td>
          <td class="paramtype">UART_HandleTypeDef *</td>          <td class="paramname"><span class="paramname"><em>huart</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span><span class="mlabel">protected</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Used to pre-process the HAL_UART_TxCpltCallback() call to the specific Driver instance. </p>

</div>
</div>
<a id="a800f5ee1920b60559228dd6329869f83" name="a800f5ee1920b60559228dd6329869f83"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a800f5ee1920b60559228dd6329869f83">&#9670;&#160;</a></span>su_txDoneIsr()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void Cpl::Io::Serial::ST::M32F4::StreamDriver::su_txDoneIsr </td>
          <td>(</td>
          <td class="paramtype">void</td>          <td class="paramname"><span class="paramname"></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>This method SHOULD only be called when the HAL Transmit operation has completed (aka from the HAL_UART_TxCpltCallback() function). </p>
<p>This method executes in the context of interrupt service routine (ISR) </p>

</div>
</div>
<a id="a2b2c14e184735307f7fda1f14b388951" name="a2b2c14e184735307f7fda1f14b388951"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2b2c14e184735307f7fda1f14b388951">&#9670;&#160;</a></span>write()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool Cpl::Io::Serial::ST::M32F4::StreamDriver::write </td>
          <td>(</td>
          <td class="paramtype">const void *</td>          <td class="paramname"><span class="paramname"><em>data</em>, </span></td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t</td>          <td class="paramname"><span class="paramname"><em>numBytesToTx</em></span>&#160;)</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Transmits the specified number of bytes. </p>
<p>The method does not return until all bytes have been transferred to the outbound buffer. The application CANNOT assume that the byte(s) have been physically transmitted on the 'wire' when this method returns. The method returns true if successful; else false is returned When an error is encounter there is no guaranty/information-available with respect to how many (if any) bytes where transmitted. </p>

</div>
</div>
<h2 class="groupheader">Member Data Documentation</h2>
<a id="a0de5bde14fbaadad55d7c1c269057dc3" name="a0de5bde14fbaadad55d7c1c269057dc3"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0de5bde14fbaadad55d7c1c269057dc3">&#9670;&#160;</a></span>m_errCount</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">size_t Cpl::Io::Serial::ST::M32F4::StreamDriver::m_errCount</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>A Receive error was encountered. </p>

</div>
</div>
<a id="a25a8858288dd9a1b21bfd7bcee22bfe2" name="a25a8858288dd9a1b21bfd7bcee22bfe2"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a25a8858288dd9a1b21bfd7bcee22bfe2">&#9670;&#160;</a></span>m_mappings</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="#struct_cpl_1_1_io_1_1_serial_1_1_s_t_1_1_m32_f4_1_1_stream_driver_1_1_hal_mapping___t">HalMapping_T</a> Cpl::Io::Serial::ST::M32F4::StreamDriver::m_mappings[<a class="el" href="_stream_driver_8h.html#a9e309e31724673a4b66a68d9415cef40">OPTION_CPL_IO_SERIAL_ST_M32F4_MAX_UARTS</a>]</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Map the HAL UART to a transmitter instance. </p>

</div>
</div>
<a id="a9192c3eb96de9739f5460877bfa38ff1" name="a9192c3eb96de9739f5460877bfa38ff1"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9192c3eb96de9739f5460877bfa38ff1">&#9670;&#160;</a></span>m_rxActive</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool Cpl::Io::Serial::ST::M32F4::StreamDriver::m_rxActive</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Receive state. </p>

</div>
</div>
<a id="ab6ff4907169ae6caf126b1f6d05a7c7a" name="ab6ff4907169ae6caf126b1f6d05a7c7a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab6ff4907169ae6caf126b1f6d05a7c7a">&#9670;&#160;</a></span>m_rxBuffer</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="class_cpl_1_1_container_1_1_ring_buffer.html">Cpl::Container::RingBuffer</a>&lt;uint8_t&gt;&amp; Cpl::Io::Serial::ST::M32F4::StreamDriver::m_rxBuffer</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Receive buffer. </p>

</div>
</div>
<a id="a1551e89e66b14f0796903b43e5454beb" name="a1551e89e66b14f0796903b43e5454beb"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1551e89e66b14f0796903b43e5454beb">&#9670;&#160;</a></span>m_rxWaiterPtr</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="class_cpl_1_1_system_1_1_thread.html">Cpl::System::Thread</a>* Cpl::Io::Serial::ST::M32F4::StreamDriver::m_rxWaiterPtr</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Handle of the blocked RX client thread (if there is one) </p>

</div>
</div>
<a id="a927db7e8911217f37337814dfff1a172" name="a927db7e8911217f37337814dfff1a172"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a927db7e8911217f37337814dfff1a172">&#9670;&#160;</a></span>m_txBuffer</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="class_cpl_1_1_container_1_1_ring_buffer.html">Cpl::Container::RingBuffer</a>&lt;uint8_t&gt;&amp; Cpl::Io::Serial::ST::M32F4::StreamDriver::m_txBuffer</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Transmit buffer. </p>

</div>
</div>
<a id="aecfc02bf747b9a74d51f921aec96b59a" name="aecfc02bf747b9a74d51f921aec96b59a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aecfc02bf747b9a74d51f921aec96b59a">&#9670;&#160;</a></span>m_txSize</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">unsigned Cpl::Io::Serial::ST::M32F4::StreamDriver::m_txSize</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Number of bytes requested to be transmitted by the HAL. </p>

</div>
</div>
<a id="ab04ecc14f69ce2b7eeb30016f45568dc" name="ab04ecc14f69ce2b7eeb30016f45568dc"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab04ecc14f69ce2b7eeb30016f45568dc">&#9670;&#160;</a></span>m_txWaiterPtr</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="class_cpl_1_1_system_1_1_thread.html">Cpl::System::Thread</a>* Cpl::Io::Serial::ST::M32F4::StreamDriver::m_txWaiterPtr</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Handle of the blocked TX client thread (if there is one) </p>

</div>
</div>
<a id="a43e124b79a14027941a313f026a5c57b" name="a43e124b79a14027941a313f026a5c57b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a43e124b79a14027941a313f026a5c57b">&#9670;&#160;</a></span>m_uartHdl</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">UART_HandleTypeDef* Cpl::Io::Serial::ST::M32F4::StreamDriver::m_uartHdl</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Handle to my low level hardware. </p>

</div>
</div>
<a id="a95a856e02b5dc595956926b6885b4aad" name="a95a856e02b5dc595956926b6885b4aad"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a95a856e02b5dc595956926b6885b4aad">&#9670;&#160;</a></span>m_uartIrqNum</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">IRQn_Type Cpl::Io::Serial::ST::M32F4::StreamDriver::m_uartIrqNum</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>IRQ number of the UART being used. </p>

</div>
</div>
<hr/>The documentation for this class was generated from the following file:<ul>
<li>Cpl/Io/Serial/ST/M32F4/<a class="el" href="_stream_driver_8h_source.html">StreamDriver.h</a></li>
</ul>
</div><!-- contents -->
<!-- start footer part -->
<hr class="footer"/><address class="footer"><small>
Generated on Thu Jul 25 2024 23:55:51 for Patterns in the Machine by&#160;<a href="https://www.doxygen.org/index.html"><img class="footer" src="doxygen.svg" width="104" height="31" alt="doxygen"/></a> 1.10.0
</small></address>
</body>
</html>
