<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "https://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=11"/>
<meta name="generator" content="Doxygen 1.9.2"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>Patterns in the Machine: Cpl::Persistent::IndexedEntryReader Class Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td id="projectlogo"><img alt="Logo" src="logo2.gif"/></td>
  <td id="projectalign" style="padding-left: 0.5em;">
   <div id="projectname">Patterns in the Machine<span id="projectnumber">&#160;$$$PROJECT_NUMBER$$$</span>
   </div>
   <div id="projectbrief">Embedded C++ Class Library</div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.9.2 -->
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
$(function() {
  initMenu('',false,false,'search.php','Search');
});
/* @license-end */
</script>
<div id="main-nav"></div>
<div id="nav-path" class="navpath">
  <ul>
<li class="navelem"><a class="el" href="namespace_cpl.html">Cpl</a></li><li class="navelem"><a class="el" href="namespace_cpl_1_1_persistent.html">Persistent</a></li><li class="navelem"><a class="el" href="class_cpl_1_1_persistent_1_1_indexed_entry_reader.html">IndexedEntryReader</a></li>  </ul>
</div>
</div><!-- top -->
<div class="header">
  <div class="summary">
<a href="class_cpl_1_1_persistent_1_1_indexed_entry_reader-members.html">List of all members</a> &#124;
<a href="#nested-classes">Classes</a> &#124;
<a href="#pub-methods">Public Member Functions</a>  </div>
  <div class="headertitle"><div class="title">Cpl::Persistent::IndexedEntryReader Class Reference<span class="mlabels"><span class="mlabel">abstract</span></span></div></div>
</div><!--header-->
<div class="contents">

<p>This abstract class defines interface for reading/retrieve 'entries' from a a collection of entries (i.e.  
 <a href="class_cpl_1_1_persistent_1_1_indexed_entry_reader.html#details">More...</a></p>
<a name="details" id="details"></a><h2 class="groupheader">Detailed Description</h2>
<div class="textblock"><p >This abstract class defines interface for reading/retrieve 'entries' from a a collection of entries (i.e. </p>
<p >read an entry from a <a class="el" href="class_cpl_1_1_persistent_1_1_indexed_entry_record.html" title="This concrete class implements the Cpl::Persistent::Record interface to store a collection &#39;entries&#39;.">IndexedEntryRecord</a>).</p>
<p >From a logical perspective, 'entries' are stored in a Ring Buffer. The Ring Buffer can be 'traversed' from the either end (i.e. oldest to newest, or newest to oldest).</p>
<p >Each entry that is stored has an 'index' value associated with it. This 'index' is used to uniquely identify each entry (even across overwritten entries) and it is used to identify the relative age between the entries.</p>
<p >NOTE: ALL entries (for a given IndexEntryRecord) must be the same fixed length.</p>
<p >NOTE: This interface/class is NOT THREAD SAFE and should only be 'used' from the <a class="el" href="class_cpl_1_1_persistent_1_1_record.html" title="This abstract class defines the public interface for a Record instance.">Record</a> Server's thread. </p>
</div>
<p><code>#include &lt;<a class="el" href="_indexed_entry_reader_8h_source.html">IndexedEntryReader.h</a>&gt;</code></p>
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a id="nested-classes" name="nested-classes"></a>
Classes</h2></td></tr>
<tr class="memitem:struct_cpl_1_1_persistent_1_1_indexed_entry_reader_1_1_entry_marker___t"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_cpl_1_1_persistent_1_1_indexed_entry_reader.html#struct_cpl_1_1_persistent_1_1_indexed_entry_reader_1_1_entry_marker___t">EntryMarker_T</a></td></tr>
<tr class="memdesc:struct_cpl_1_1_persistent_1_1_indexed_entry_reader_1_1_entry_marker___t"><td class="mdescLeft">&#160;</td><td class="mdescRight">This structure define an 'marker' that identifies an entry's location in persistent media.  <a href="class_cpl_1_1_persistent_1_1_indexed_entry_reader.html#struct_cpl_1_1_persistent_1_1_indexed_entry_reader_1_1_entry_marker___t">More...</a><br /></td></tr>
<tr class="separator:struct_cpl_1_1_persistent_1_1_indexed_entry_reader_1_1_entry_marker___t"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a id="pub-methods" name="pub-methods"></a>
Public Member Functions</h2></td></tr>
<tr class="memitem:a8b1f7eea076fd2bd72bde3e1ee0b1cb7"><td class="memItemLeft" align="right" valign="top">virtual bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_cpl_1_1_persistent_1_1_indexed_entry_reader.html#a8b1f7eea076fd2bd72bde3e1ee0b1cb7">getLatest</a> (<a class="el" href="class_cpl_1_1_persistent_1_1_payload.html">Payload</a> &amp;dst, <a class="el" href="class_cpl_1_1_persistent_1_1_indexed_entry_reader.html#struct_cpl_1_1_persistent_1_1_indexed_entry_reader_1_1_entry_marker___t">EntryMarker_T</a> &amp;entryMarker) noexcept=0</td></tr>
<tr class="memdesc:a8b1f7eea076fd2bd72bde3e1ee0b1cb7"><td class="mdescLeft">&#160;</td><td class="mdescRight">This method reads/retrieves the latest entry (from the list of Indexed Entries) stored in the persistent media.  <a href="class_cpl_1_1_persistent_1_1_indexed_entry_reader.html#a8b1f7eea076fd2bd72bde3e1ee0b1cb7">More...</a><br /></td></tr>
<tr class="separator:a8b1f7eea076fd2bd72bde3e1ee0b1cb7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a12358b768c6becf7e52d485b63668f93"><td class="memItemLeft" align="right" valign="top">virtual bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_cpl_1_1_persistent_1_1_indexed_entry_reader.html#a12358b768c6becf7e52d485b63668f93">getNext</a> (uint64_t newerThan, const <a class="el" href="class_cpl_1_1_persistent_1_1_indexed_entry_reader.html#struct_cpl_1_1_persistent_1_1_indexed_entry_reader_1_1_entry_marker___t">EntryMarker_T</a> beginHereMarker, <a class="el" href="class_cpl_1_1_persistent_1_1_payload.html">Payload</a> &amp;dst, <a class="el" href="class_cpl_1_1_persistent_1_1_indexed_entry_reader.html#struct_cpl_1_1_persistent_1_1_indexed_entry_reader_1_1_entry_marker___t">EntryMarker_T</a> &amp;entryMarker) noexcept=0</td></tr>
<tr class="memdesc:a12358b768c6becf7e52d485b63668f93"><td class="mdescLeft">&#160;</td><td class="mdescRight">This method walks the entire 'list of entries' and returns the next newer entry as specified by the 'newerThan' value.  <a href="class_cpl_1_1_persistent_1_1_indexed_entry_reader.html#a12358b768c6becf7e52d485b63668f93">More...</a><br /></td></tr>
<tr class="separator:a12358b768c6becf7e52d485b63668f93"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aab0a17c1dd6ac47eac3f51a817e5bfd2"><td class="memItemLeft" align="right" valign="top">virtual bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_cpl_1_1_persistent_1_1_indexed_entry_reader.html#aab0a17c1dd6ac47eac3f51a817e5bfd2">getPrevious</a> (uint64_t olderThan, const <a class="el" href="class_cpl_1_1_persistent_1_1_indexed_entry_reader.html#struct_cpl_1_1_persistent_1_1_indexed_entry_reader_1_1_entry_marker___t">EntryMarker_T</a> beginHereMarker, <a class="el" href="class_cpl_1_1_persistent_1_1_payload.html">Payload</a> &amp;dst, <a class="el" href="class_cpl_1_1_persistent_1_1_indexed_entry_reader.html#struct_cpl_1_1_persistent_1_1_indexed_entry_reader_1_1_entry_marker___t">EntryMarker_T</a> &amp;entryMarker) noexcept=0</td></tr>
<tr class="memdesc:aab0a17c1dd6ac47eac3f51a817e5bfd2"><td class="mdescLeft">&#160;</td><td class="mdescRight">This method is similar to <a class="el" href="class_cpl_1_1_persistent_1_1_indexed_entry_reader.html#a12358b768c6becf7e52d485b63668f93" title="This method walks the entire &#39;list of entries&#39; and returns the next newer entry as specified by the &#39;...">getNext()</a>, except that it returns the next oldest entry.  <a href="class_cpl_1_1_persistent_1_1_indexed_entry_reader.html#aab0a17c1dd6ac47eac3f51a817e5bfd2">More...</a><br /></td></tr>
<tr class="separator:aab0a17c1dd6ac47eac3f51a817e5bfd2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a58472f64f0d7736d341d2903e0178237"><td class="memItemLeft" align="right" valign="top">virtual bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_cpl_1_1_persistent_1_1_indexed_entry_reader.html#a58472f64f0d7736d341d2903e0178237">getByBufferIndex</a> (size_t bufferIndex, <a class="el" href="class_cpl_1_1_persistent_1_1_payload.html">Payload</a> &amp;dst, <a class="el" href="class_cpl_1_1_persistent_1_1_indexed_entry_reader.html#struct_cpl_1_1_persistent_1_1_indexed_entry_reader_1_1_entry_marker___t">EntryMarker_T</a> &amp;entryMarker) noexcept=0</td></tr>
<tr class="memdesc:a58472f64f0d7736d341d2903e0178237"><td class="mdescLeft">&#160;</td><td class="mdescRight">This method can be used to read an entry by its 'buffer index'.  <a href="class_cpl_1_1_persistent_1_1_indexed_entry_reader.html#a58472f64f0d7736d341d2903e0178237">More...</a><br /></td></tr>
<tr class="separator:a58472f64f0d7736d341d2903e0178237"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad768d2c1e33d68e7d7af1e3ab5c2b69e"><td class="memItemLeft" align="right" valign="top">virtual size_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_cpl_1_1_persistent_1_1_indexed_entry_reader.html#ad768d2c1e33d68e7d7af1e3ab5c2b69e">getMaxIndex</a> () const noexcept=0</td></tr>
<tr class="memdesc:ad768d2c1e33d68e7d7af1e3ab5c2b69e"><td class="mdescLeft">&#160;</td><td class="mdescRight">This method returns the maximum allowed 'bufferIndex' when calling getByIndex().  <a href="class_cpl_1_1_persistent_1_1_indexed_entry_reader.html#ad768d2c1e33d68e7d7af1e3ab5c2b69e">More...</a><br /></td></tr>
<tr class="separator:ad768d2c1e33d68e7d7af1e3ab5c2b69e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9cee26946be0049ad18830adbba18529"><td class="memItemLeft" align="right" valign="top">virtual&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_cpl_1_1_persistent_1_1_indexed_entry_reader.html#a9cee26946be0049ad18830adbba18529">~IndexedEntryReader</a> ()</td></tr>
<tr class="memdesc:a9cee26946be0049ad18830adbba18529"><td class="mdescLeft">&#160;</td><td class="mdescRight">Virtual destructor.  <a href="class_cpl_1_1_persistent_1_1_indexed_entry_reader.html#a9cee26946be0049ad18830adbba18529">More...</a><br /></td></tr>
<tr class="separator:a9cee26946be0049ad18830adbba18529"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<hr/><h2 class="groupheader">Class Documentation</h2>
<a name="struct_cpl_1_1_persistent_1_1_indexed_entry_reader_1_1_entry_marker___t" id="struct_cpl_1_1_persistent_1_1_indexed_entry_reader_1_1_entry_marker___t"></a>
<h2 class="memtitle"><span class="permalink"><a href="#struct_cpl_1_1_persistent_1_1_indexed_entry_reader_1_1_entry_marker___t">&#9670;&nbsp;</a></span>Cpl::Persistent::IndexedEntryReader::EntryMarker_T</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">struct Cpl::Persistent::IndexedEntryReader::EntryMarker_T</td>
        </tr>
      </table>
</div><div class="memdoc">
<div class="textblock"><p >This structure define an 'marker' that identifies an entry's location in persistent media. </p>
</div><table class="fieldtable">
<tr><th colspan="3">Class Members</th></tr>
<tr><td class="fieldtype">
<a id="ac2aeb47c39934552af1d8ac40235acdb" name="ac2aeb47c39934552af1d8ac40235acdb"></a>uint64_t</td>
<td class="fieldname">
indexValue</td>
<td class="fielddoc">
The index/timestamp value for the entry (Note: This is NOT the 'Buffer Index' used by the <a class="el" href="class_cpl_1_1_persistent_1_1_indexed_entry_reader.html#a58472f64f0d7736d341d2903e0178237" title="This method can be used to read an entry by its &#39;buffer index&#39;.">getByBufferIndex()</a> call) </td></tr>
<tr><td class="fieldtype">
<a id="a3979755dad111e2f50ca3d11aa3cc647" name="a3979755dad111e2f50ca3d11aa3cc647"></a>size_t</td>
<td class="fieldname">
mediaOffset</td>
<td class="fielddoc">
Offset, within a <a class="el" href="class_cpl_1_1_persistent_1_1_region_media.html" title="This mostly abstract class defines the operations that can be performed on a persistent media.">RegionMedia</a> to the start of the Entry. </td></tr>
</table>

</div>
</div>
<h2 class="groupheader">Constructor &amp; Destructor Documentation</h2>
<a id="a9cee26946be0049ad18830adbba18529" name="a9cee26946be0049ad18830adbba18529"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9cee26946be0049ad18830adbba18529">&#9670;&nbsp;</a></span>~IndexedEntryReader()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual Cpl::Persistent::IndexedEntryReader::~IndexedEntryReader </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Virtual destructor. </p>

</div>
</div>
<h2 class="groupheader">Member Function Documentation</h2>
<a id="a58472f64f0d7736d341d2903e0178237" name="a58472f64f0d7736d341d2903e0178237"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a58472f64f0d7736d341d2903e0178237">&#9670;&nbsp;</a></span>getByBufferIndex()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual bool Cpl::Persistent::IndexedEntryReader::getByBufferIndex </td>
          <td>(</td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>bufferIndex</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="class_cpl_1_1_persistent_1_1_payload.html">Payload</a> &amp;&#160;</td>
          <td class="paramname"><em>dst</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="class_cpl_1_1_persistent_1_1_indexed_entry_reader.html#struct_cpl_1_1_persistent_1_1_indexed_entry_reader_1_1_entry_marker___t">EntryMarker_T</a> &amp;&#160;</td>
          <td class="paramname"><em>entryMarker</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">pure virtual</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>This method can be used to read an entry by its 'buffer index'. </p>
<p >The buffer index is a zero based index.</p>
<p >Returns true if the entry at 'bufferIndex' is a valid entry; else false is returned. Note: if 'bufferIndex' is out of range, false is returned.</p>
<p >NOTE: 'dst' is ALWAYS updated EVEN if no valid entry was 'found', basically 'dst' is used as a work buffer when traversing the list. </p>

</div>
</div>
<a id="a8b1f7eea076fd2bd72bde3e1ee0b1cb7" name="a8b1f7eea076fd2bd72bde3e1ee0b1cb7"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8b1f7eea076fd2bd72bde3e1ee0b1cb7">&#9670;&nbsp;</a></span>getLatest()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual bool Cpl::Persistent::IndexedEntryReader::getLatest </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="class_cpl_1_1_persistent_1_1_payload.html">Payload</a> &amp;&#160;</td>
          <td class="paramname"><em>dst</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="class_cpl_1_1_persistent_1_1_indexed_entry_reader.html#struct_cpl_1_1_persistent_1_1_indexed_entry_reader_1_1_entry_marker___t">EntryMarker_T</a> &amp;&#160;</td>
          <td class="paramname"><em>entryMarker</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">pure virtual</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>This method reads/retrieves the latest entry (from the list of Indexed Entries) stored in the persistent media. </p>
<p >The method is synchronous in that the method does not return until the entry has been 'read' from the persistent media.</p>
<p >Returns true if the latest entry is valid and has been read into 'dst'; else false is returned.</p>
<p >NOTE: When <a class="el" href="class_cpl_1_1_persistent_1_1_indexed_entry_reader.html#a8b1f7eea076fd2bd72bde3e1ee0b1cb7" title="This method reads/retrieves the latest entry (from the list of Indexed Entries) stored in the persist...">getLatest()</a> returns false, this means there are NO entries stored.</p>
<p >NOTE: 'dst' is ALWAYS updated EVEN if no entry was 'found', basically 'dst' is used as a work buffer when traversing the list. </p>

</div>
</div>
<a id="ad768d2c1e33d68e7d7af1e3ab5c2b69e" name="ad768d2c1e33d68e7d7af1e3ab5c2b69e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad768d2c1e33d68e7d7af1e3ab5c2b69e">&#9670;&nbsp;</a></span>getMaxIndex()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual size_t Cpl::Persistent::IndexedEntryReader::getMaxIndex </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">pure virtual</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>This method returns the maximum allowed 'bufferIndex' when calling getByIndex(). </p>

</div>
</div>
<a id="a12358b768c6becf7e52d485b63668f93" name="a12358b768c6becf7e52d485b63668f93"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a12358b768c6becf7e52d485b63668f93">&#9670;&nbsp;</a></span>getNext()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual bool Cpl::Persistent::IndexedEntryReader::getNext </td>
          <td>(</td>
          <td class="paramtype">uint64_t&#160;</td>
          <td class="paramname"><em>newerThan</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="class_cpl_1_1_persistent_1_1_indexed_entry_reader.html#struct_cpl_1_1_persistent_1_1_indexed_entry_reader_1_1_entry_marker___t">EntryMarker_T</a>&#160;</td>
          <td class="paramname"><em>beginHereMarker</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="class_cpl_1_1_persistent_1_1_payload.html">Payload</a> &amp;&#160;</td>
          <td class="paramname"><em>dst</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="class_cpl_1_1_persistent_1_1_indexed_entry_reader.html#struct_cpl_1_1_persistent_1_1_indexed_entry_reader_1_1_entry_marker___t">EntryMarker_T</a> &amp;&#160;</td>
          <td class="paramname"><em>entryMarker</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">pure virtual</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>This method walks the entire 'list of entries' and returns the next newer entry as specified by the 'newerThan' value. </p>
<p >The traversal starts with the 'beginHereMarker' The method is synchronous in that the method does not return until the entry has been 'read' from the persistent media.</p>
<p >Returns true if the 'next' entry was found and has been read into 'dst'; else false is returned.</p>
<p >NOTE: 'dst' is ALWAYS updated EVEN if no entry was 'found', basically 'dst' is used as a work buffer when traversing the list. </p>

</div>
</div>
<a id="aab0a17c1dd6ac47eac3f51a817e5bfd2" name="aab0a17c1dd6ac47eac3f51a817e5bfd2"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aab0a17c1dd6ac47eac3f51a817e5bfd2">&#9670;&nbsp;</a></span>getPrevious()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual bool Cpl::Persistent::IndexedEntryReader::getPrevious </td>
          <td>(</td>
          <td class="paramtype">uint64_t&#160;</td>
          <td class="paramname"><em>olderThan</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="class_cpl_1_1_persistent_1_1_indexed_entry_reader.html#struct_cpl_1_1_persistent_1_1_indexed_entry_reader_1_1_entry_marker___t">EntryMarker_T</a>&#160;</td>
          <td class="paramname"><em>beginHereMarker</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="class_cpl_1_1_persistent_1_1_payload.html">Payload</a> &amp;&#160;</td>
          <td class="paramname"><em>dst</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="class_cpl_1_1_persistent_1_1_indexed_entry_reader.html#struct_cpl_1_1_persistent_1_1_indexed_entry_reader_1_1_entry_marker___t">EntryMarker_T</a> &amp;&#160;</td>
          <td class="paramname"><em>entryMarker</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">pure virtual</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>This method is similar to <a class="el" href="class_cpl_1_1_persistent_1_1_indexed_entry_reader.html#a12358b768c6becf7e52d485b63668f93" title="This method walks the entire &#39;list of entries&#39; and returns the next newer entry as specified by the &#39;...">getNext()</a>, except that it returns the next oldest entry. </p>

</div>
</div>
<hr/>The documentation for this class was generated from the following file:<ul>
<li>Cpl/Persistent/<a class="el" href="_indexed_entry_reader_8h_source.html">IndexedEntryReader.h</a></li>
</ul>
</div><!-- contents -->
<!-- start footer part -->
<hr class="footer"/><address class="footer"><small>
Generated on Sun Dec 25 2022 14:37:56 for Patterns in the Machine by&#160;<a href="https://www.doxygen.org/index.html"><img class="footer" src="doxygen.svg" width="104" height="31" alt="doxygen"/></a> 1.9.2
</small></address>
</body>
</html>
