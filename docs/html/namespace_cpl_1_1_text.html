<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "https://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.8.18"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>PIM: Cpl::Text Namespace Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td id="projectlogo"><img alt="Logo" src="logo2.gif"/></td>
  <td id="projectalign" style="padding-left: 0.5em;">
   <div id="projectname">PIM
   </div>
   <div id="projectbrief">Patterns in the Machine: Thermostat Example</div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.8.18 -->
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
$(function() {
  initMenu('',false,false,'search.php','Search');
});
/* @license-end */</script>
<div id="main-nav"></div>
<div id="nav-path" class="navpath">
  <ul>
<li class="navelem"><a class="el" href="namespace_cpl.html">Cpl</a></li><li class="navelem"><a class="el" href="namespace_cpl_1_1_text.html">Text</a></li>  </ul>
</div>
</div><!-- top -->
<div class="header">
  <div class="summary">
<a href="#namespaces">Namespaces</a> &#124;
<a href="#nested-classes">Classes</a> &#124;
<a href="#func-members">Functions</a>  </div>
  <div class="headertitle">
<div class="title">Cpl::Text Namespace Reference</div>  </div>
</div><!--header-->
<div class="contents">
<a name="details" id="details"></a><h2 class="groupheader">Detailed Description</h2>
<div class="textblock"><p>The <a class="el" href="namespace_cpl_1_1_text.html">Text</a> namespace provides yet-another <a class="el" href="class_cpl_1_1_text_1_1_string.html" title="This abstract class defines the operations that can be before on a NULL terminated string.">String</a> class and additional string and/or text processing utilities. What makes the <a class="el" href="class_cpl_1_1_text_1_1_string.html" title="This abstract class defines the operations that can be before on a NULL terminated string.">Cpl::Text::String</a> classes different from other <a class="el" href="class_cpl_1_1_text_1_1_string.html" title="This abstract class defines the operations that can be before on a NULL terminated string.">String</a> classes is that it supports a ZERO dynamic memory allocation interface and implementation. There is also a dynamic memory implementation of the <a class="el" href="class_cpl_1_1_text_1_1_string.html" title="This abstract class defines the operations that can be before on a NULL terminated string.">String</a> interface for when strict memory management is not required. </p>
</div><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="namespaces"></a>
Namespaces</h2></td></tr>
<tr class="memitem:namespace_cpl_1_1_text_1_1_frame"><td class="memItemLeft" align="right" valign="top"> &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespace_cpl_1_1_text_1_1_frame.html">Frame</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:namespace_cpl_1_1_text_1_1_tokenizer"><td class="memItemLeft" align="right" valign="top"> &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespace_cpl_1_1_text_1_1_tokenizer.html">Tokenizer</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="nested-classes"></a>
Classes</h2></td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_cpl_1_1_text_1_1_d_f_string.html">DFString</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">This concrete class is a mix of <a class="el" href="class_cpl_1_1_text_1_1_f_string.html" title="This template class represents a NULL terminated string of a specific length.">FString</a> and a <a class="el" href="class_cpl_1_1_text_1_1_d_string.html" title="This concrete class implements a simple &quot;dynamic storage&quot; String Type.">DString</a> - the initial memory is dynamically allocated - but no additional memory allocation will occur after the instance is created, i.e.  <a href="class_cpl_1_1_text_1_1_d_f_string.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_cpl_1_1_text_1_1_d_f_string_item.html">DFStringItem</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">This concrete class implements the <a class="el" href="class_cpl_1_1_text_1_1_string_item.html" title="This partially concrete provides a wrapper class that allows a String object to be stored directly in...">StringItem</a> class for a '<a class="el" href="class_cpl_1_1_text_1_1_string.html" title="This abstract class defines the operations that can be before on a NULL terminated string.">String</a>' using a '<a class="el" href="class_cpl_1_1_text_1_1_d_f_string.html" title="This concrete class is a mix of FString and a DString - the initial memory is dynamically allocated -...">DFString</a>' as the internal storage for <a class="el" href="class_cpl_1_1_text_1_1_string.html" title="This abstract class defines the operations that can be before on a NULL terminated string.">String</a> instance.  <a href="class_cpl_1_1_text_1_1_d_f_string_item.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_cpl_1_1_text_1_1_d_string.html">DString</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">This concrete class implements a simple "dynamic storage" <a class="el" href="class_cpl_1_1_text_1_1_string.html" title="This abstract class defines the operations that can be before on a NULL terminated string.">String</a> <a class="el" href="namespace_cpl_1_1_type.html">Type</a>.  <a href="class_cpl_1_1_text_1_1_d_string.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_cpl_1_1_text_1_1_d_string_item.html">DStringItem</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">This concrete class implements the <a class="el" href="class_cpl_1_1_text_1_1_string_item.html" title="This partially concrete provides a wrapper class that allows a String object to be stored directly in...">StringItem</a> class for a '<a class="el" href="class_cpl_1_1_text_1_1_string.html" title="This abstract class defines the operations that can be before on a NULL terminated string.">String</a>' using a '<a class="el" href="class_cpl_1_1_text_1_1_d_string.html" title="This concrete class implements a simple &quot;dynamic storage&quot; String Type.">DString</a>' as the internal storage for <a class="el" href="class_cpl_1_1_text_1_1_string.html" title="This abstract class defines the operations that can be before on a NULL terminated string.">String</a> instance.  <a href="class_cpl_1_1_text_1_1_d_string_item.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_cpl_1_1_text_1_1_f_string.html">FString</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">This template class represents a NULL terminated string of a specific length.  <a href="class_cpl_1_1_text_1_1_f_string.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_cpl_1_1_text_1_1_f_string__.html">FString_</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">This mostly concrete class implements a "fixed storage" <a class="el" href="class_cpl_1_1_text_1_1_string.html" title="This abstract class defines the operations that can be before on a NULL terminated string.">String</a> <a class="el" href="namespace_cpl_1_1_type.html">Type</a>.  <a href="class_cpl_1_1_text_1_1_f_string__.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_cpl_1_1_text_1_1_f_string_item.html">FStringItem</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">This template class implements the <a class="el" href="class_cpl_1_1_text_1_1_string_item.html" title="This partially concrete provides a wrapper class that allows a String object to be stored directly in...">StringItem</a> class for a '<a class="el" href="class_cpl_1_1_text_1_1_string.html" title="This abstract class defines the operations that can be before on a NULL terminated string.">String</a>' using a '<a class="el" href="class_cpl_1_1_text_1_1_f_string.html" title="This template class represents a NULL terminated string of a specific length.">FString</a>' as the internal storage for <a class="el" href="class_cpl_1_1_text_1_1_string.html" title="This abstract class defines the operations that can be before on a NULL terminated string.">String</a> instance.  <a href="class_cpl_1_1_text_1_1_f_string_item.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_cpl_1_1_text_1_1_string.html">String</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">This abstract class defines the operations that can be before on a NULL terminated string.  <a href="class_cpl_1_1_text_1_1_string.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_cpl_1_1_text_1_1_string__.html">String_</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">This partially concrete class implements the portions of the <a class="el" href="class_cpl_1_1_text_1_1_string.html" title="This abstract class defines the operations that can be before on a NULL terminated string.">String</a> Api that is independent of the internal storage mechanisms.  <a href="class_cpl_1_1_text_1_1_string__.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_cpl_1_1_text_1_1_string_item.html">StringItem</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">This partially concrete provides a wrapper class that allows a <a class="el" href="class_cpl_1_1_text_1_1_string.html" title="This abstract class defines the operations that can be before on a NULL terminated string.">String</a> object to be stored directly in one the CPL Containers.  <a href="class_cpl_1_1_text_1_1_string_item.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="func-members"></a>
Functions</h2></td></tr>
<tr class="memitem:a7023b131150bf6e746c6eae38daf4294"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespace_cpl_1_1_text.html#a7023b131150bf6e746c6eae38daf4294">a2i</a> (int &amp;convertedValue, const char *string, int base=10, const char *validStopChars=0, const char **endptr=0)</td></tr>
<tr class="memdesc:a7023b131150bf6e746c6eae38daf4294"><td class="mdescLeft">&#160;</td><td class="mdescRight">This method converts the specified string to an integer.  <a href="namespace_cpl_1_1_text.html#a7023b131150bf6e746c6eae38daf4294">More...</a><br /></td></tr>
<tr class="separator:a7023b131150bf6e746c6eae38daf4294"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5545e025ede3938fd5e326ea84a8d846"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespace_cpl_1_1_text.html#a5545e025ede3938fd5e326ea84a8d846">a2ui</a> (unsigned &amp;convertedValue, const char *string, int base=10, const char *validStopChars=0, const char **endptr=0)</td></tr>
<tr class="memdesc:a5545e025ede3938fd5e326ea84a8d846"><td class="mdescLeft">&#160;</td><td class="mdescRight">This method is the same as <a class="el" href="namespace_cpl_1_1_text.html#a7023b131150bf6e746c6eae38daf4294" title="This method converts the specified string to an integer.">a2i()</a> except that it converts unsigned integer.  <a href="namespace_cpl_1_1_text.html#a5545e025ede3938fd5e326ea84a8d846">More...</a><br /></td></tr>
<tr class="separator:a5545e025ede3938fd5e326ea84a8d846"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afb577681a19f3b6562acd0c3eb7095b4"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespace_cpl_1_1_text.html#afb577681a19f3b6562acd0c3eb7095b4">a2l</a> (long &amp;convertedValue, const char *string, int base=10, const char *validStopChars=0, const char **endptr=0)</td></tr>
<tr class="memdesc:afb577681a19f3b6562acd0c3eb7095b4"><td class="mdescLeft">&#160;</td><td class="mdescRight">This method is the same as <a class="el" href="namespace_cpl_1_1_text.html#a7023b131150bf6e746c6eae38daf4294" title="This method converts the specified string to an integer.">a2i()</a> except that it converts long integer.  <a href="namespace_cpl_1_1_text.html#afb577681a19f3b6562acd0c3eb7095b4">More...</a><br /></td></tr>
<tr class="separator:afb577681a19f3b6562acd0c3eb7095b4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a06c830e654edfb12fac73cd26dcadfd7"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespace_cpl_1_1_text.html#a06c830e654edfb12fac73cd26dcadfd7">a2ul</a> (unsigned long &amp;convertedValue, const char *string, int base=10, const char *validStopChars=0, const char **endptr=0)</td></tr>
<tr class="memdesc:a06c830e654edfb12fac73cd26dcadfd7"><td class="mdescLeft">&#160;</td><td class="mdescRight">This method is the same as <a class="el" href="namespace_cpl_1_1_text.html#a7023b131150bf6e746c6eae38daf4294" title="This method converts the specified string to an integer.">a2i()</a> except that it converts unsigned long integer.  <a href="namespace_cpl_1_1_text.html#a06c830e654edfb12fac73cd26dcadfd7">More...</a><br /></td></tr>
<tr class="separator:a06c830e654edfb12fac73cd26dcadfd7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4912f3974cf06ae6e39c336473a81f3c"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespace_cpl_1_1_text.html#a4912f3974cf06ae6e39c336473a81f3c">a2ll</a> (long long &amp;convertedValue, const char *string, int base=10, const char *validStopChars=0, const char **endptr=0)</td></tr>
<tr class="memdesc:a4912f3974cf06ae6e39c336473a81f3c"><td class="mdescLeft">&#160;</td><td class="mdescRight">This method is the same as <a class="el" href="namespace_cpl_1_1_text.html#a7023b131150bf6e746c6eae38daf4294" title="This method converts the specified string to an integer.">a2i()</a> except that it converts long long integer.  <a href="namespace_cpl_1_1_text.html#a4912f3974cf06ae6e39c336473a81f3c">More...</a><br /></td></tr>
<tr class="separator:a4912f3974cf06ae6e39c336473a81f3c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0c51a67b6587ebfafe35ea064075d828"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespace_cpl_1_1_text.html#a0c51a67b6587ebfafe35ea064075d828">a2ull</a> (unsigned long long &amp;convertedValue, const char *string, int base=10, const char *validStopChars=0, const char **endptr=0)</td></tr>
<tr class="memdesc:a0c51a67b6587ebfafe35ea064075d828"><td class="mdescLeft">&#160;</td><td class="mdescRight">This method is the same as <a class="el" href="namespace_cpl_1_1_text.html#a7023b131150bf6e746c6eae38daf4294" title="This method converts the specified string to an integer.">a2i()</a> except that it converts unsigned long long integer.  <a href="namespace_cpl_1_1_text.html#a0c51a67b6587ebfafe35ea064075d828">More...</a><br /></td></tr>
<tr class="separator:a0c51a67b6587ebfafe35ea064075d828"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a926efe9ed5a7d87873a82fd377872d8d"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespace_cpl_1_1_text.html#a926efe9ed5a7d87873a82fd377872d8d">a2d</a> (double &amp;convertedValue, const char *string, const char *validStopChars=0, const char **endptr=0)</td></tr>
<tr class="memdesc:a926efe9ed5a7d87873a82fd377872d8d"><td class="mdescLeft">&#160;</td><td class="mdescRight">This method converts the specified string to an double.  <a href="namespace_cpl_1_1_text.html#a926efe9ed5a7d87873a82fd377872d8d">More...</a><br /></td></tr>
<tr class="separator:a926efe9ed5a7d87873a82fd377872d8d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae1c0d2f2152fd16d950b7a44a3b7b1bd"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespace_cpl_1_1_text.html#ae1c0d2f2152fd16d950b7a44a3b7b1bd">a2b</a> (bool &amp;convertedValue, const char *string, const char *trueToken=&quot;T&quot;, const char *falseToken=&quot;F&quot;, const char **endptr=0)</td></tr>
<tr class="memdesc:ae1c0d2f2152fd16d950b7a44a3b7b1bd"><td class="mdescLeft">&#160;</td><td class="mdescRight">This method convert the specified string to an boolean.  <a href="namespace_cpl_1_1_text.html#ae1c0d2f2152fd16d950b7a44a3b7b1bd">More...</a><br /></td></tr>
<tr class="separator:ae1c0d2f2152fd16d950b7a44a3b7b1bd"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a02e148e7ecbd1c9368d8ee1a61984705"><td class="memItemLeft" align="right" valign="top">long&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespace_cpl_1_1_text.html#a02e148e7ecbd1c9368d8ee1a61984705">asciiHexToBuffer</a> (void *dstBinary, const char *srcString, size_t dstMaxLen)</td></tr>
<tr class="memdesc:a02e148e7ecbd1c9368d8ee1a61984705"><td class="mdescLeft">&#160;</td><td class="mdescRight">This method will convert an 'ASCII HEX' string to an equivalent binary buffer, i.e.  <a href="namespace_cpl_1_1_text.html#a02e148e7ecbd1c9368d8ee1a61984705">More...</a><br /></td></tr>
<tr class="separator:a02e148e7ecbd1c9368d8ee1a61984705"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a365931bdae91b7355a26372e042889f4"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespace_cpl_1_1_text.html#a365931bdae91b7355a26372e042889f4">parsePrecisionTimeStamp</a> (const char *timeStampToParse, <a class="el" href="class_cpl_1_1_system_1_1_elapsed_time.html#a4bd9b9cef62b7bd5e55aef23435de0fe">Cpl::System::ElapsedTime::Precision_T</a> &amp;convertedValue)</td></tr>
<tr class="memdesc:a365931bdae91b7355a26372e042889f4"><td class="mdescLeft">&#160;</td><td class="mdescRight">This method parses a 'timestamp' with the following format: [DD ]HH:MM:SS[.sss] The method returns true if the parse was successful.  <a href="namespace_cpl_1_1_text.html#a365931bdae91b7355a26372e042889f4">More...</a><br /></td></tr>
<tr class="separator:a365931bdae91b7355a26372e042889f4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a167bfcc845b3eb1a86e4a4b9371f06a2"><td class="memItemLeft" align="right" valign="top">const char *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespace_cpl_1_1_text.html#a167bfcc845b3eb1a86e4a4b9371f06a2">longToStr</a> (long num, char *dstString, size_t maxChars, unsigned base=10, char padChar=' ')</td></tr>
<tr class="memdesc:a167bfcc845b3eb1a86e4a4b9371f06a2"><td class="mdescLeft">&#160;</td><td class="mdescRight">This method converts a long to a string.  <a href="namespace_cpl_1_1_text.html#a167bfcc845b3eb1a86e4a4b9371f06a2">More...</a><br /></td></tr>
<tr class="separator:a167bfcc845b3eb1a86e4a4b9371f06a2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6639a376b674cb3de007cc741d7263a9"><td class="memItemLeft" align="right" valign="top">const char *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespace_cpl_1_1_text.html#a6639a376b674cb3de007cc741d7263a9">ulongToStr</a> (unsigned long num, char *dstString, size_t maxChars, unsigned base=10, char padChar=' ')</td></tr>
<tr class="memdesc:a6639a376b674cb3de007cc741d7263a9"><td class="mdescLeft">&#160;</td><td class="mdescRight">This method is same as <a class="el" href="namespace_cpl_1_1_text.html#a167bfcc845b3eb1a86e4a4b9371f06a2" title="This method converts a long to a string.">longToStr()</a>, except it converts a unsigned long value.  <a href="namespace_cpl_1_1_text.html#a6639a376b674cb3de007cc741d7263a9">More...</a><br /></td></tr>
<tr class="separator:a6639a376b674cb3de007cc741d7263a9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a25083a69914e16fa63919d228798cde9"><td class="memItemLeft" align="right" valign="top">const char *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespace_cpl_1_1_text.html#a25083a69914e16fa63919d228798cde9">sizetToStr</a> (size_t num, char *dstString, size_t maxChars, unsigned base=10, char padChar=' ')</td></tr>
<tr class="memdesc:a25083a69914e16fa63919d228798cde9"><td class="mdescLeft">&#160;</td><td class="mdescRight">This method is same as <a class="el" href="namespace_cpl_1_1_text.html#a167bfcc845b3eb1a86e4a4b9371f06a2" title="This method converts a long to a string.">longToStr()</a>, except it converts a size_t value.  <a href="namespace_cpl_1_1_text.html#a25083a69914e16fa63919d228798cde9">More...</a><br /></td></tr>
<tr class="separator:a25083a69914e16fa63919d228798cde9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a958036b6c1d71de588912e2ee2e1cfa6"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespace_cpl_1_1_text.html#a958036b6c1d71de588912e2ee2e1cfa6">bufferToString</a> (const void *buffer, int len, <a class="el" href="class_cpl_1_1_text_1_1_string.html">Cpl::Text::String</a> &amp;destString, bool appendToString=false)</td></tr>
<tr class="memdesc:a958036b6c1d71de588912e2ee2e1cfa6"><td class="mdescLeft">&#160;</td><td class="mdescRight">This method will take a raw data buffer and convert it to an 'viewable' string.  <a href="namespace_cpl_1_1_text.html#a958036b6c1d71de588912e2ee2e1cfa6">More...</a><br /></td></tr>
<tr class="separator:a958036b6c1d71de588912e2ee2e1cfa6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7e7c089cfd4ae54c701c8000293a62eb"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespace_cpl_1_1_text.html#a7e7c089cfd4ae54c701c8000293a62eb">bufferToAsciiHex</a> (const void *binaryData, int len, <a class="el" href="class_cpl_1_1_text_1_1_string.html">Cpl::Text::String</a> &amp;destString, bool upperCase=true, bool appendToString=false)</td></tr>
<tr class="memdesc:a7e7c089cfd4ae54c701c8000293a62eb"><td class="mdescLeft">&#160;</td><td class="mdescRight">This method will convert a binary buffer to 'ASCII HEX', e.g.  <a href="namespace_cpl_1_1_text.html#a7e7c089cfd4ae54c701c8000293a62eb">More...</a><br /></td></tr>
<tr class="separator:a7e7c089cfd4ae54c701c8000293a62eb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac81a7c3db0fdf1ece0a09bdb73ef8e9c"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespace_cpl_1_1_text.html#ac81a7c3db0fdf1ece0a09bdb73ef8e9c">formatMsecTimeStamp</a> (<a class="el" href="class_cpl_1_1_text_1_1_string.html">Cpl::Text::String</a> &amp;buffer, unsigned long long timeStampInMsecs, bool encodeDay=true, bool appendToString=false)</td></tr>
<tr class="memdesc:ac81a7c3db0fdf1ece0a09bdb73ef8e9c"><td class="mdescLeft">&#160;</td><td class="mdescRight">This method converts the binary millisecond count of 'timeStampInMsecs' to a string with the following format: "DD HH:MM:SS.SSS".  <a href="namespace_cpl_1_1_text.html#ac81a7c3db0fdf1ece0a09bdb73ef8e9c">More...</a><br /></td></tr>
<tr class="separator:ac81a7c3db0fdf1ece0a09bdb73ef8e9c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab519c3ecf8ad77149f44dc41ef73f843"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespace_cpl_1_1_text.html#ab519c3ecf8ad77149f44dc41ef73f843">formatSecTimeStamp</a> (<a class="el" href="class_cpl_1_1_text_1_1_string.html">Cpl::Text::String</a> &amp;buffer, unsigned long long timeStampInSecs, bool encodeDay=true, bool appendToString=false)</td></tr>
<tr class="memdesc:ab519c3ecf8ad77149f44dc41ef73f843"><td class="mdescLeft">&#160;</td><td class="mdescRight">This method converts the binary second count of 'timeStampInSecs' to a string with the following format: "DD HH:MM:SS".  <a href="namespace_cpl_1_1_text.html#ab519c3ecf8ad77149f44dc41ef73f843">More...</a><br /></td></tr>
<tr class="separator:ab519c3ecf8ad77149f44dc41ef73f843"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a58a2435abd2d2b7393fbc4bf0f4eba2f"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespace_cpl_1_1_text.html#a58a2435abd2d2b7393fbc4bf0f4eba2f">formatPrecisionTimeStamp</a> (<a class="el" href="class_cpl_1_1_text_1_1_string.html">Cpl::Text::String</a> &amp;buffer, <a class="el" href="class_cpl_1_1_system_1_1_elapsed_time.html#a4bd9b9cef62b7bd5e55aef23435de0fe">Cpl::System::ElapsedTime::Precision_T</a> timeStamp, bool encodeDay=true, bool appendToString=false)</td></tr>
<tr class="memdesc:a58a2435abd2d2b7393fbc4bf0f4eba2f"><td class="mdescLeft">&#160;</td><td class="mdescRight">This method converts the <a class="el" href="class_cpl_1_1_system_1_1_elapsed_time.html#a4bd9b9cef62b7bd5e55aef23435de0fe" title="Data type for time in seconds with a &#39;fractional&#39; millisecond precision.">Cpl::System::ElapsedTime::Precision_T</a> value of time into a string with the following format: "DD HH:MM:SS.SSS".  <a href="namespace_cpl_1_1_text.html#a58a2435abd2d2b7393fbc4bf0f4eba2f">More...</a><br /></td></tr>
<tr class="separator:a58a2435abd2d2b7393fbc4bf0f4eba2f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac14e61c7a26d37010bdfe93ade5b59ba"><td class="memItemLeft" align="right" valign="top">const char *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespace_cpl_1_1_text.html#ac14e61c7a26d37010bdfe93ade5b59ba">stripSpace</a> (const char *s)</td></tr>
<tr class="memdesc:ac14e61c7a26d37010bdfe93ade5b59ba"><td class="mdescLeft">&#160;</td><td class="mdescRight">This method returns a pointer to the FIRST non-whitespace character in the the specified null-terminated string.  <a href="namespace_cpl_1_1_text.html#ac14e61c7a26d37010bdfe93ade5b59ba">More...</a><br /></td></tr>
<tr class="separator:ac14e61c7a26d37010bdfe93ade5b59ba"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad42c55345a21ef44d3d0f05b6db6f8ec"><td class="memItemLeft" align="right" valign="top">const char *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespace_cpl_1_1_text.html#ad42c55345a21ef44d3d0f05b6db6f8ec">stripNotSpace</a> (const char *s)</td></tr>
<tr class="memdesc:ad42c55345a21ef44d3d0f05b6db6f8ec"><td class="mdescLeft">&#160;</td><td class="mdescRight">This method returns a pointer to the FIRST whitespace character in the the specified null-terminated string.  <a href="namespace_cpl_1_1_text.html#ad42c55345a21ef44d3d0f05b6db6f8ec">More...</a><br /></td></tr>
<tr class="separator:ad42c55345a21ef44d3d0f05b6db6f8ec"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a08a9a7fd5c7962fc037dd8ab9fd51355"><td class="memItemLeft" align="right" valign="top">const char *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespace_cpl_1_1_text.html#a08a9a7fd5c7962fc037dd8ab9fd51355">stripTrailingSpace</a> (const char *s)</td></tr>
<tr class="memdesc:a08a9a7fd5c7962fc037dd8ab9fd51355"><td class="mdescLeft">&#160;</td><td class="mdescRight">This method returns a pointer to the LAST non-whitespace character in the the specified null-terminated string.  <a href="namespace_cpl_1_1_text.html#a08a9a7fd5c7962fc037dd8ab9fd51355">More...</a><br /></td></tr>
<tr class="separator:a08a9a7fd5c7962fc037dd8ab9fd51355"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af1cb01066ac4701cb10670ee4325e44b"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespace_cpl_1_1_text.html#af1cb01066ac4701cb10670ee4325e44b">removeTrailingSpace</a> (char *s)</td></tr>
<tr class="memdesc:af1cb01066ac4701cb10670ee4325e44b"><td class="mdescLeft">&#160;</td><td class="mdescRight">This method TRUNCATES the specified null-terminated string by eliminating any trailing white space.  <a href="namespace_cpl_1_1_text.html#af1cb01066ac4701cb10670ee4325e44b">More...</a><br /></td></tr>
<tr class="separator:af1cb01066ac4701cb10670ee4325e44b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aaeb3cd13b0126b677c9dce381cfc09a0"><td class="memItemLeft" align="right" valign="top">const char *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespace_cpl_1_1_text.html#aaeb3cd13b0126b677c9dce381cfc09a0">stripChars</a> (const char *s, const char *charsSet)</td></tr>
<tr class="memdesc:aaeb3cd13b0126b677c9dce381cfc09a0"><td class="mdescLeft">&#160;</td><td class="mdescRight">This method is the same as <a class="el" href="namespace_cpl_1_1_text.html#ac14e61c7a26d37010bdfe93ade5b59ba" title="This method returns a pointer to the FIRST non-whitespace character in the the specified null-termina...">stripSpace()</a>, except the specified character set is used to terminate the search instead of the standard isspace() characters.  <a href="namespace_cpl_1_1_text.html#aaeb3cd13b0126b677c9dce381cfc09a0">More...</a><br /></td></tr>
<tr class="separator:aaeb3cd13b0126b677c9dce381cfc09a0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5854e604efe16644059855ce4a8a9e04"><td class="memItemLeft" align="right" valign="top">const char *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespace_cpl_1_1_text.html#a5854e604efe16644059855ce4a8a9e04">stripNotChars</a> (const char *s, const char *charsSet)</td></tr>
<tr class="memdesc:a5854e604efe16644059855ce4a8a9e04"><td class="mdescLeft">&#160;</td><td class="mdescRight">This method is the same as <a class="el" href="namespace_cpl_1_1_text.html#ad42c55345a21ef44d3d0f05b6db6f8ec" title="This method returns a pointer to the FIRST whitespace character in the the specified null-terminated ...">stripNotSpace()</a>, except the specified character set is used to terminate the search instead of the standard isspace() characters.  <a href="namespace_cpl_1_1_text.html#a5854e604efe16644059855ce4a8a9e04">More...</a><br /></td></tr>
<tr class="separator:a5854e604efe16644059855ce4a8a9e04"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7480520348029f1b992f6fbef338010d"><td class="memItemLeft" align="right" valign="top">const char *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespace_cpl_1_1_text.html#a7480520348029f1b992f6fbef338010d">stripTrailingChars</a> (const char *s, const char *charsSet)</td></tr>
<tr class="memdesc:a7480520348029f1b992f6fbef338010d"><td class="mdescLeft">&#160;</td><td class="mdescRight">This method is the same as stripTrailingSpaces(), except the specified character set is used to identify the last "non-whitespace" character.  <a href="namespace_cpl_1_1_text.html#a7480520348029f1b992f6fbef338010d">More...</a><br /></td></tr>
<tr class="separator:a7480520348029f1b992f6fbef338010d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aae9a2f33932dfaa319c5eb23b36fe8de"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespace_cpl_1_1_text.html#aae9a2f33932dfaa319c5eb23b36fe8de">removeTrailingChars</a> (char *s, const char *charsSet)</td></tr>
<tr class="memdesc:aae9a2f33932dfaa319c5eb23b36fe8de"><td class="mdescLeft">&#160;</td><td class="mdescRight">This method is the same as removeTrailingSpaces(), except the specified characters set is used for "whitespace" any trailing white space.  <a href="namespace_cpl_1_1_text.html#aae9a2f33932dfaa319c5eb23b36fe8de">More...</a><br /></td></tr>
<tr class="separator:aae9a2f33932dfaa319c5eb23b36fe8de"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3f46f4bb0cba3cd95b91d1c1f639eabe"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespace_cpl_1_1_text.html#a3f46f4bb0cba3cd95b91d1c1f639eabe">isCharInString</a> (const char *charsSet, const char c)</td></tr>
<tr class="memdesc:a3f46f4bb0cba3cd95b91d1c1f639eabe"><td class="mdescLeft">&#160;</td><td class="mdescRight">This method returns true if the character 'c' is one of character(s) contained in 'charsSet'; else false is returned.  <a href="namespace_cpl_1_1_text.html#a3f46f4bb0cba3cd95b91d1c1f639eabe">More...</a><br /></td></tr>
<tr class="separator:a3f46f4bb0cba3cd95b91d1c1f639eabe"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<h2 class="groupheader">Function Documentation</h2>
<a id="ae1c0d2f2152fd16d950b7a44a3b7b1bd"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae1c0d2f2152fd16d950b7a44a3b7b1bd">&#9670;&nbsp;</a></span>a2b()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool Cpl::Text::a2b </td>
          <td>(</td>
          <td class="paramtype">bool &amp;&#160;</td>
          <td class="paramname"><em>convertedValue</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>string</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>trueToken</em> = <code>&quot;T&quot;</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>falseToken</em> = <code>&quot;F&quot;</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char **&#160;</td>
          <td class="paramname"><em>endptr</em> = <code>0</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>This method convert the specified string to an boolean. </p>
<p>The method returns true if the conversion was successful. When false is returned, the 'convertedValue' argument is NOT updated. If the first N characters of 'string' match the specified boolean token - the conversion is consider successful (i.e. there is no required separator/terminator character for a boolean token). If endptr is specified and the method returns true, a pointer to the first character 'after' the boolean token is returned. </p>

</div>
</div>
<a id="a926efe9ed5a7d87873a82fd377872d8d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a926efe9ed5a7d87873a82fd377872d8d">&#9670;&nbsp;</a></span>a2d()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool Cpl::Text::a2d </td>
          <td>(</td>
          <td class="paramtype">double &amp;&#160;</td>
          <td class="paramname"><em>convertedValue</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>string</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>validStopChars</em> = <code>0</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char **&#160;</td>
          <td class="paramname"><em>endptr</em> = <code>0</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>This method converts the specified string to an double. </p>
<p>The method returns true if the conversion was successful. When false is returned, the 'convertedValue' argument is NOT updated. By default the conversion assumes that the 'end-of-number' is end-of-string. If endptr is specified and the method returns true, a pointer to the first character 'after' the number is returned. </p>

</div>
</div>
<a id="a7023b131150bf6e746c6eae38daf4294"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7023b131150bf6e746c6eae38daf4294">&#9670;&nbsp;</a></span>a2i()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool Cpl::Text::a2i </td>
          <td>(</td>
          <td class="paramtype">int &amp;&#160;</td>
          <td class="paramname"><em>convertedValue</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>string</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>base</em> = <code>10</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>validStopChars</em> = <code>0</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char **&#160;</td>
          <td class="paramname"><em>endptr</em> = <code>0</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>This method converts the specified string to an integer. </p>
<p>The method returns true if the conversion was successful. When false is returned, the 'convertedValue' argument is NOT updated. By default the conversion assumes a base 10 number and that the 'end-of-number' is end-of-string. If endptr is specified and the conversation was successful, a pointer to the first character 'after' the number is returned. </p>

</div>
</div>
<a id="afb577681a19f3b6562acd0c3eb7095b4"></a>
<h2 class="memtitle"><span class="permalink"><a href="#afb577681a19f3b6562acd0c3eb7095b4">&#9670;&nbsp;</a></span>a2l()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool Cpl::Text::a2l </td>
          <td>(</td>
          <td class="paramtype">long &amp;&#160;</td>
          <td class="paramname"><em>convertedValue</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>string</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>base</em> = <code>10</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>validStopChars</em> = <code>0</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char **&#160;</td>
          <td class="paramname"><em>endptr</em> = <code>0</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>This method is the same as <a class="el" href="namespace_cpl_1_1_text.html#a7023b131150bf6e746c6eae38daf4294" title="This method converts the specified string to an integer.">a2i()</a> except that it converts long integer. </p>

</div>
</div>
<a id="a4912f3974cf06ae6e39c336473a81f3c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a4912f3974cf06ae6e39c336473a81f3c">&#9670;&nbsp;</a></span>a2ll()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool Cpl::Text::a2ll </td>
          <td>(</td>
          <td class="paramtype">long long &amp;&#160;</td>
          <td class="paramname"><em>convertedValue</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>string</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>base</em> = <code>10</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>validStopChars</em> = <code>0</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char **&#160;</td>
          <td class="paramname"><em>endptr</em> = <code>0</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>This method is the same as <a class="el" href="namespace_cpl_1_1_text.html#a7023b131150bf6e746c6eae38daf4294" title="This method converts the specified string to an integer.">a2i()</a> except that it converts long long integer. </p>

</div>
</div>
<a id="a5545e025ede3938fd5e326ea84a8d846"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5545e025ede3938fd5e326ea84a8d846">&#9670;&nbsp;</a></span>a2ui()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool Cpl::Text::a2ui </td>
          <td>(</td>
          <td class="paramtype">unsigned &amp;&#160;</td>
          <td class="paramname"><em>convertedValue</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>string</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>base</em> = <code>10</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>validStopChars</em> = <code>0</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char **&#160;</td>
          <td class="paramname"><em>endptr</em> = <code>0</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>This method is the same as <a class="el" href="namespace_cpl_1_1_text.html#a7023b131150bf6e746c6eae38daf4294" title="This method converts the specified string to an integer.">a2i()</a> except that it converts unsigned integer. </p>

</div>
</div>
<a id="a06c830e654edfb12fac73cd26dcadfd7"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a06c830e654edfb12fac73cd26dcadfd7">&#9670;&nbsp;</a></span>a2ul()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool Cpl::Text::a2ul </td>
          <td>(</td>
          <td class="paramtype">unsigned long &amp;&#160;</td>
          <td class="paramname"><em>convertedValue</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>string</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>base</em> = <code>10</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>validStopChars</em> = <code>0</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char **&#160;</td>
          <td class="paramname"><em>endptr</em> = <code>0</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>This method is the same as <a class="el" href="namespace_cpl_1_1_text.html#a7023b131150bf6e746c6eae38daf4294" title="This method converts the specified string to an integer.">a2i()</a> except that it converts unsigned long integer. </p>

</div>
</div>
<a id="a0c51a67b6587ebfafe35ea064075d828"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0c51a67b6587ebfafe35ea064075d828">&#9670;&nbsp;</a></span>a2ull()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool Cpl::Text::a2ull </td>
          <td>(</td>
          <td class="paramtype">unsigned long long &amp;&#160;</td>
          <td class="paramname"><em>convertedValue</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>string</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>base</em> = <code>10</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>validStopChars</em> = <code>0</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char **&#160;</td>
          <td class="paramname"><em>endptr</em> = <code>0</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>This method is the same as <a class="el" href="namespace_cpl_1_1_text.html#a7023b131150bf6e746c6eae38daf4294" title="This method converts the specified string to an integer.">a2i()</a> except that it converts unsigned long long integer. </p>

</div>
</div>
<a id="a02e148e7ecbd1c9368d8ee1a61984705"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a02e148e7ecbd1c9368d8ee1a61984705">&#9670;&nbsp;</a></span>asciiHexToBuffer()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">long Cpl::Text::asciiHexToBuffer </td>
          <td>(</td>
          <td class="paramtype">void *&#160;</td>
          <td class="paramname"><em>dstBinary</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>srcString</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>dstMaxLen</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>This method will convert an 'ASCII HEX' string to an equivalent binary buffer, i.e. </p>
<p>the reverse of <a class="el" href="namespace_cpl_1_1_text.html#a7e7c089cfd4ae54c701c8000293a62eb" title="This method will convert a binary buffer to &#39;ASCII HEX&#39;, e.g.">bufferToAsciiHex()</a> in <a class="el" href="format_8h.html">format.h</a>. If the entire string was not able to be converted then -1 is returned, else the number of converted bytes are returned. </p>

</div>
</div>
<a id="a7e7c089cfd4ae54c701c8000293a62eb"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7e7c089cfd4ae54c701c8000293a62eb">&#9670;&nbsp;</a></span>bufferToAsciiHex()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool Cpl::Text::bufferToAsciiHex </td>
          <td>(</td>
          <td class="paramtype">const void *&#160;</td>
          <td class="paramname"><em>binaryData</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>len</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="class_cpl_1_1_text_1_1_string.html">Cpl::Text::String</a> &amp;&#160;</td>
          <td class="paramname"><em>destString</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>upperCase</em> = <code>true</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>appendToString</em> = <code>false</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>This method will convert a binary buffer to 'ASCII HEX', e.g. </p>
<p>given the binary data of { 12, F2, 54 }, destString:= "12F254". The method will return true if buffer was successfully converted, i.e. the ENTIRE buffer was converted to a string; else false is returned (this include the cases of null 'buffer' pointer, 'len' equals zero, or not enough memory in 'destString' to contain the final result).</p>
<p>Note: The default operation is to use uppercase text and to clear the destString before the conversion. </p>

</div>
</div>
<a id="a958036b6c1d71de588912e2ee2e1cfa6"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a958036b6c1d71de588912e2ee2e1cfa6">&#9670;&nbsp;</a></span>bufferToString()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool Cpl::Text::bufferToString </td>
          <td>(</td>
          <td class="paramtype">const void *&#160;</td>
          <td class="paramname"><em>buffer</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>len</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="class_cpl_1_1_text_1_1_string.html">Cpl::Text::String</a> &amp;&#160;</td>
          <td class="paramname"><em>destString</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>appendToString</em> = <code>false</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>This method will take a raw data buffer and convert it to an 'viewable' string. </p>
<p>Non-printable values will displayed as '.'. Note: The default operation is to clear the destString before the conversion. The method will return if buffer was successfully converted, i.e. the ENTIRE buffer was converted; else false is returned (this include the cases of null 'buffer' pointer, 'len' equals zero, or not enough memory in 'destString' to contain the final result). </p>

</div>
</div>
<a id="ac81a7c3db0fdf1ece0a09bdb73ef8e9c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac81a7c3db0fdf1ece0a09bdb73ef8e9c">&#9670;&nbsp;</a></span>formatMsecTimeStamp()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool Cpl::Text::formatMsecTimeStamp </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="class_cpl_1_1_text_1_1_string.html">Cpl::Text::String</a> &amp;&#160;</td>
          <td class="paramname"><em>buffer</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned long long&#160;</td>
          <td class="paramname"><em>timeStampInMsecs</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>encodeDay</em> = <code>true</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>appendToString</em> = <code>false</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>This method converts the binary millisecond count of 'timeStampInMsecs' to a string with the following format: "DD HH:MM:SS.SSS". </p>
<p>The converted result is returned via 'buffer'. If the results where truncated by the no enough memory in 'buffer' then false is returned; else true is returned. </p>

</div>
</div>
<a id="a58a2435abd2d2b7393fbc4bf0f4eba2f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a58a2435abd2d2b7393fbc4bf0f4eba2f">&#9670;&nbsp;</a></span>formatPrecisionTimeStamp()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool Cpl::Text::formatPrecisionTimeStamp </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="class_cpl_1_1_text_1_1_string.html">Cpl::Text::String</a> &amp;&#160;</td>
          <td class="paramname"><em>buffer</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="class_cpl_1_1_system_1_1_elapsed_time.html#a4bd9b9cef62b7bd5e55aef23435de0fe">Cpl::System::ElapsedTime::Precision_T</a>&#160;</td>
          <td class="paramname"><em>timeStamp</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>encodeDay</em> = <code>true</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>appendToString</em> = <code>false</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>This method converts the <a class="el" href="class_cpl_1_1_system_1_1_elapsed_time.html#a4bd9b9cef62b7bd5e55aef23435de0fe" title="Data type for time in seconds with a &#39;fractional&#39; millisecond precision.">Cpl::System::ElapsedTime::Precision_T</a> value of time into a string with the following format: "DD HH:MM:SS.SSS". </p>
<p>The converted result is returned via 'buffer'. If the results where truncated by the no enough memory in 'buffer' then false is returned; else true is returned. </p>

</div>
</div>
<a id="ab519c3ecf8ad77149f44dc41ef73f843"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab519c3ecf8ad77149f44dc41ef73f843">&#9670;&nbsp;</a></span>formatSecTimeStamp()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool Cpl::Text::formatSecTimeStamp </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="class_cpl_1_1_text_1_1_string.html">Cpl::Text::String</a> &amp;&#160;</td>
          <td class="paramname"><em>buffer</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned long long&#160;</td>
          <td class="paramname"><em>timeStampInSecs</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>encodeDay</em> = <code>true</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>appendToString</em> = <code>false</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>This method converts the binary second count of 'timeStampInSecs' to a string with the following format: "DD HH:MM:SS". </p>
<p>The converted result is returned via 'buffer'. If the results where truncated by the no enough memory in 'buffer' then false is returned; else true is returned. </p>

</div>
</div>
<a id="a3f46f4bb0cba3cd95b91d1c1f639eabe"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3f46f4bb0cba3cd95b91d1c1f639eabe">&#9670;&nbsp;</a></span>isCharInString()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool Cpl::Text::isCharInString </td>
          <td>(</td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>charsSet</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char&#160;</td>
          <td class="paramname"><em>c</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>This method returns true if the character 'c' is one of character(s) contained in 'charsSet'; else false is returned. </p>

</div>
</div>
<a id="a167bfcc845b3eb1a86e4a4b9371f06a2"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a167bfcc845b3eb1a86e4a4b9371f06a2">&#9670;&nbsp;</a></span>longToStr()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">const char* Cpl::Text::longToStr </td>
          <td>(</td>
          <td class="paramtype">long&#160;</td>
          <td class="paramname"><em>num</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">char *&#160;</td>
          <td class="paramname"><em>dstString</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>maxChars</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned&#160;</td>
          <td class="paramname"><em>base</em> = <code>10</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">char&#160;</td>
          <td class="paramname"><em>padChar</em> = <code>'&#160;'</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>This method converts a long to a string. </p>
<p>If the number of converted digits exceeds the size of 'dstString', then the MOST significant digit(s) are discarded. When 'num' is negative there will always be a leading minus sign ('-') even if it means discarding a MOST significant digit. There is no feedback if/when digits are discarded.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">num</td><td>number to convert </td></tr>
    <tr><td class="paramname">dstString</td><td>buffer to hold the output </td></tr>
    <tr><td class="paramname">maxChars</td><td>size, in bytes, of 'dstString'. Note: This includes the space for the null terminator </td></tr>
    <tr><td class="paramname">base</td><td>Number base for conversion </td></tr>
    <tr><td class="paramname">padChar</td><td>The character to use to pad any unused leading characters in 'dstString'</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>a pointer to the beginning of the converted number when successful; else 0 is returned on error (e.g. illegal 'base' value). The returned pointer is essentially a left justified string of the converted value. For a right justified result, use the original pointer passed as 'dstString'. </dd></dl>

</div>
</div>
<a id="a365931bdae91b7355a26372e042889f4"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a365931bdae91b7355a26372e042889f4">&#9670;&nbsp;</a></span>parsePrecisionTimeStamp()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool Cpl::Text::parsePrecisionTimeStamp </td>
          <td>(</td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>timeStampToParse</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="class_cpl_1_1_system_1_1_elapsed_time.html#a4bd9b9cef62b7bd5e55aef23435de0fe">Cpl::System::ElapsedTime::Precision_T</a> &amp;&#160;</td>
          <td class="paramname"><em>convertedValue</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>This method parses a 'timestamp' with the following format: [DD ]HH:MM:SS[.sss] The method returns true if the parse was successful. </p>

</div>
</div>
<a id="aae9a2f33932dfaa319c5eb23b36fe8de"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aae9a2f33932dfaa319c5eb23b36fe8de">&#9670;&nbsp;</a></span>removeTrailingChars()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void Cpl::Text::removeTrailingChars </td>
          <td>(</td>
          <td class="paramtype">char *&#160;</td>
          <td class="paramname"><em>s</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>charsSet</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>This method is the same as removeTrailingSpaces(), except the specified characters set is used for "whitespace" any trailing white space. </p>
<p>NOTE: If 's' OR 'charsSet' is null, then nothing is done. </p>

</div>
</div>
<a id="af1cb01066ac4701cb10670ee4325e44b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af1cb01066ac4701cb10670ee4325e44b">&#9670;&nbsp;</a></span>removeTrailingSpace()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void Cpl::Text::removeTrailingSpace </td>
          <td>(</td>
          <td class="paramtype">char *&#160;</td>
          <td class="paramname"><em>s</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>This method TRUNCATES the specified null-terminated string by eliminating any trailing white space. </p>
<p>NOTE: If 's' is null, then nothing is done. </p>

</div>
</div>
<a id="a25083a69914e16fa63919d228798cde9"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a25083a69914e16fa63919d228798cde9">&#9670;&nbsp;</a></span>sizetToStr()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">const char* Cpl::Text::sizetToStr </td>
          <td>(</td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>num</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">char *&#160;</td>
          <td class="paramname"><em>dstString</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>maxChars</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned&#160;</td>
          <td class="paramname"><em>base</em> = <code>10</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">char&#160;</td>
          <td class="paramname"><em>padChar</em> = <code>'&#160;'</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>This method is same as <a class="el" href="namespace_cpl_1_1_text.html#a167bfcc845b3eb1a86e4a4b9371f06a2" title="This method converts a long to a string.">longToStr()</a>, except it converts a size_t value. </p>

</div>
</div>
<a id="aaeb3cd13b0126b677c9dce381cfc09a0"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aaeb3cd13b0126b677c9dce381cfc09a0">&#9670;&nbsp;</a></span>stripChars()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">const char* Cpl::Text::stripChars </td>
          <td>(</td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>s</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>charsSet</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>This method is the same as <a class="el" href="namespace_cpl_1_1_text.html#ac14e61c7a26d37010bdfe93ade5b59ba" title="This method returns a pointer to the FIRST non-whitespace character in the the specified null-termina...">stripSpace()</a>, except the specified character set is used to terminate the search instead of the standard isspace() characters. </p>
<p>NOTES: </p><pre class="fragment">o If 's' is null, then null is returned
o If 'charsSet' is null, then 's' is returned and nothing is done.
</pre> 
</div>
</div>
<a id="a5854e604efe16644059855ce4a8a9e04"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5854e604efe16644059855ce4a8a9e04">&#9670;&nbsp;</a></span>stripNotChars()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">const char* Cpl::Text::stripNotChars </td>
          <td>(</td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>s</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>charsSet</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>This method is the same as <a class="el" href="namespace_cpl_1_1_text.html#ad42c55345a21ef44d3d0f05b6db6f8ec" title="This method returns a pointer to the FIRST whitespace character in the the specified null-terminated ...">stripNotSpace()</a>, except the specified character set is used to terminate the search instead of the standard isspace() characters. </p>
<p>NOTES: </p><pre class="fragment">o If 's' is null, then null is returned
o If 'charsSet' is null, then 's' is returned and nothing is done.
</pre> 
</div>
</div>
<a id="ad42c55345a21ef44d3d0f05b6db6f8ec"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad42c55345a21ef44d3d0f05b6db6f8ec">&#9670;&nbsp;</a></span>stripNotSpace()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">const char* Cpl::Text::stripNotSpace </td>
          <td>(</td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>s</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>This method returns a pointer to the FIRST whitespace character in the the specified null-terminated string. </p>
<p>NOTES: </p><pre class="fragment">o This method does NOT modify the original string in any way!
o If 's' is null, then null is returned.
</pre><p>This method is useful in finding the 'next' token in a string, for example: </p><div class="fragment"><div class="line"><span class="comment">// Returns a pointer to the first token in &#39;input&#39;</span></div>
<div class="line"><span class="keyword">const</span> <span class="keywordtype">char</span>* token = <a class="code" href="namespace_cpl_1_1_text.html#ac14e61c7a26d37010bdfe93ade5b59ba">stripSpace</a>(input)</div>
<div class="line"> </div>
<div class="line"><span class="comment">// Returns a pointer to the second token in &#39;input&#39;</span></div>
<div class="line">token = <a class="code" href="namespace_cpl_1_1_text.html#ac14e61c7a26d37010bdfe93ade5b59ba">stripSpace</a>(<a class="code" href="namespace_cpl_1_1_text.html#ad42c55345a21ef44d3d0f05b6db6f8ec">stripNotSpace</a>(token))</div>
</div><!-- fragment --> 
</div>
</div>
<a id="ac14e61c7a26d37010bdfe93ade5b59ba"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac14e61c7a26d37010bdfe93ade5b59ba">&#9670;&nbsp;</a></span>stripSpace()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">const char* Cpl::Text::stripSpace </td>
          <td>(</td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>s</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>This method returns a pointer to the FIRST non-whitespace character in the the specified null-terminated string. </p>
<p>NOTES: </p><pre class="fragment">o This method does NOT modify the original string in any way!
o If 's' is null, then null is returned.
</pre> 
</div>
</div>
<a id="a7480520348029f1b992f6fbef338010d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7480520348029f1b992f6fbef338010d">&#9670;&nbsp;</a></span>stripTrailingChars()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">const char* Cpl::Text::stripTrailingChars </td>
          <td>(</td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>s</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>charsSet</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>This method is the same as stripTrailingSpaces(), except the specified character set is used to identify the last "non-whitespace" character. </p>
<p>NOTES: </p><pre class="fragment">o If 's' is null, then null is returned
o If 'charsSet' is null, then 's' is returned and nothing is done.
o If the entire string is made up of 'charsSet', a pointer to the start
  of the string is returned (i.e. 's' returned)
</pre> 
</div>
</div>
<a id="a08a9a7fd5c7962fc037dd8ab9fd51355"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a08a9a7fd5c7962fc037dd8ab9fd51355">&#9670;&nbsp;</a></span>stripTrailingSpace()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">const char* Cpl::Text::stripTrailingSpace </td>
          <td>(</td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>s</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>This method returns a pointer to the LAST non-whitespace character in the the specified null-terminated string. </p>
<p>NOTES: </p><pre class="fragment">o This method does NOT modify the original string in any way!
o If 's' is null, then null is returned.
o If the entire string is whitespace, a pointer to the start of
  the string is returned (i.e. 's' returned)
</pre> 
</div>
</div>
<a id="a6639a376b674cb3de007cc741d7263a9"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6639a376b674cb3de007cc741d7263a9">&#9670;&nbsp;</a></span>ulongToStr()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">const char* Cpl::Text::ulongToStr </td>
          <td>(</td>
          <td class="paramtype">unsigned long&#160;</td>
          <td class="paramname"><em>num</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">char *&#160;</td>
          <td class="paramname"><em>dstString</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>maxChars</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned&#160;</td>
          <td class="paramname"><em>base</em> = <code>10</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">char&#160;</td>
          <td class="paramname"><em>padChar</em> = <code>'&#160;'</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>This method is same as <a class="el" href="namespace_cpl_1_1_text.html#a167bfcc845b3eb1a86e4a4b9371f06a2" title="This method converts a long to a string.">longToStr()</a>, except it converts a unsigned long value. </p>

</div>
</div>
</div><!-- contents -->
<div class="ttc" id="anamespace_cpl_1_1_text_html_ad42c55345a21ef44d3d0f05b6db6f8ec"><div class="ttname"><a href="namespace_cpl_1_1_text.html#ad42c55345a21ef44d3d0f05b6db6f8ec">Cpl::Text::stripNotSpace</a></div><div class="ttdeci">const char * stripNotSpace(const char *s)</div><div class="ttdoc">This method returns a pointer to the FIRST whitespace character in the the specified null-terminated ...</div></div>
<div class="ttc" id="anamespace_cpl_1_1_text_html_ac14e61c7a26d37010bdfe93ade5b59ba"><div class="ttname"><a href="namespace_cpl_1_1_text.html#ac14e61c7a26d37010bdfe93ade5b59ba">Cpl::Text::stripSpace</a></div><div class="ttdeci">const char * stripSpace(const char *s)</div><div class="ttdoc">This method returns a pointer to the FIRST non-whitespace character in the the specified null-termina...</div></div>
<!-- start footer part -->
<hr class="footer"/><address class="footer"><small>
Generated on Thu Dec 10 2020 16:32:58 for PIM by &#160;<a href="http://www.doxygen.org/index.html">
<img class="footer" src="doxygen.png" alt="doxygen"/>
</a> 1.8.18
</small></address>
</body>
</html>
