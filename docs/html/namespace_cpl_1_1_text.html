<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "https://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml" lang="en-US">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=11"/>
<meta name="generator" content="Doxygen 1.10.0"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>Patterns in the Machine: Cpl::Text Namespace Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr id="projectrow">
  <td id="projectlogo"><img alt="Logo" src="logo2.gif"/></td>
  <td id="projectalign">
   <div id="projectname">Patterns in the Machine<span id="projectnumber">&#160;$$$PROJECT_NUMBER$$$</span>
   </div>
   <div id="projectbrief">Embedded C++ Class Library</div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.10.0 -->
  <div id="navrow1" class="tabs">
    <ul class="tablist">
      <li><a href="index.html"><span>Main&#160;Page</span></a></li>
      <li class="current"><a href="namespaces.html"><span>Namespaces</span></a></li>
      <li><a href="annotated.html"><span>Components</span></a></li>
      <li><a href="files.html"><span>Files</span></a></li>
    </ul>
  </div>
  <div id="navrow2" class="tabs2">
    <ul class="tablist">
      <li><a href="namespaces.html"><span>Namespace&#160;List</span></a></li>
      <li><a href="namespacemembers.html"><span>Namespace&#160;Members</span></a></li>
    </ul>
  </div>
<div id="nav-path" class="navpath">
  <ul>
<li class="navelem"><a class="el" href="namespace_cpl.html">Cpl</a></li><li class="navelem"><a class="el" href="namespace_cpl_1_1_text.html">Text</a></li>  </ul>
</div>
</div><!-- top -->
<div class="header">
  <div class="summary">
<a href="#namespaces">Namespaces</a> &#124;
<a href="#nested-classes">Classes</a> &#124;
<a href="#func-members">Functions</a>  </div>
  <div class="headertitle"><div class="title">Cpl::Text Namespace Reference</div></div>
</div><!--header-->
<div class="contents">

<p>The <a class="el" href="namespace_cpl_1_1_text.html" title="The Text namespace provides yet-another String class and additional string and/or text processing uti...">Text</a> namespace provides yet-another <a class="el" href="class_cpl_1_1_text_1_1_string.html" title="This abstract class defines the operations that can be before on a NULL terminated string.">String</a> class and additional string and/or text processing utilities.  
<a href="#details">More...</a></p>
<a name="details" id="details"></a><h2 class="groupheader">Detailed Description</h2>
<div class="textblock"><p>The <a class="el" href="namespace_cpl_1_1_text.html" title="The Text namespace provides yet-another String class and additional string and/or text processing uti...">Text</a> namespace provides yet-another <a class="el" href="class_cpl_1_1_text_1_1_string.html" title="This abstract class defines the operations that can be before on a NULL terminated string.">String</a> class and additional string and/or text processing utilities. </p>
<p>What makes the <a class="el" href="class_cpl_1_1_text_1_1_string.html" title="This abstract class defines the operations that can be before on a NULL terminated string.">Cpl::Text::String</a> classes different from other <a class="el" href="class_cpl_1_1_text_1_1_string.html" title="This abstract class defines the operations that can be before on a NULL terminated string.">String</a> classes is that it supports a ZERO dynamic memory allocation interface and implementation. There is also a dynamic memory implementation of the <a class="el" href="class_cpl_1_1_text_1_1_string.html" title="This abstract class defines the operations that can be before on a NULL terminated string.">String</a> interface for when strict memory management is not required. </p>
</div><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a id="namespaces" name="namespaces"></a>
Namespaces</h2></td></tr>
<tr class="memitem:namespace_cpl_1_1_text_1_1_encoding" id="r_namespace_cpl_1_1_text_1_1_encoding"><td class="memItemLeft" align="right" valign="top">namespace &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespace_cpl_1_1_text_1_1_encoding.html">Encoding</a></td></tr>
<tr class="memdesc:namespace_cpl_1_1_text_1_1_encoding"><td class="mdescLeft">&#160;</td><td class="mdescRight">The '<a class="el" href="namespace_cpl_1_1_text_1_1_encoding.html" title="The &#39;Encoding&#39; namespace provides various encoding algorithms for converting binary data to (and from...">Encoding</a>' namespace provides various encoding algorithms for converting binary data to (and from) ASCII text to facilitate transport of the binary data using text based protocols. <br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:namespace_cpl_1_1_text_1_1_frame" id="r_namespace_cpl_1_1_text_1_1_frame"><td class="memItemLeft" align="right" valign="top">namespace &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespace_cpl_1_1_text_1_1_frame.html">Frame</a></td></tr>
<tr class="memdesc:namespace_cpl_1_1_text_1_1_frame"><td class="mdescLeft">&#160;</td><td class="mdescRight">The <a class="el" href="namespace_cpl_1_1_text_1_1_frame.html" title="The Frame namespace provides interfaces for encoding and decoding text frames.">Frame</a> namespace provides interfaces for encoding and decoding text frames. <br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:namespace_cpl_1_1_text_1_1_tokenizer" id="r_namespace_cpl_1_1_text_1_1_tokenizer"><td class="memItemLeft" align="right" valign="top">namespace &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespace_cpl_1_1_text_1_1_tokenizer.html">Tokenizer</a></td></tr>
<tr class="memdesc:namespace_cpl_1_1_text_1_1_tokenizer"><td class="mdescLeft">&#160;</td><td class="mdescRight">The <a class="el" href="namespace_cpl_1_1_text_1_1_tokenizer.html" title="The Tokenizer namespace provides interfaces for tokenizing strings.">Tokenizer</a> namespace provides interfaces for tokenizing strings. <br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a id="nested-classes" name="nested-classes"></a>
Classes</h2></td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_cpl_1_1_text_1_1_d_f_string.html">DFString</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">This concrete class is a mix of <a class="el" href="class_cpl_1_1_text_1_1_f_string.html" title="This template class represents a NULL terminated string of a specific length.">FString</a> and a <a class="el" href="class_cpl_1_1_text_1_1_d_string.html" title="This concrete class implements a simple &quot;dynamic storage&quot; String Type.">DString</a> - the initial memory is dynamically allocated - but no additional memory allocation will occur after the instance is created, i.e.  <a href="class_cpl_1_1_text_1_1_d_f_string.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_cpl_1_1_text_1_1_d_f_string_item.html">DFStringItem</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">This concrete class implements the <a class="el" href="class_cpl_1_1_text_1_1_string_item.html" title="This partially concrete provides a wrapper class that allows a String object to be stored directly in...">StringItem</a> class for a '<a class="el" href="class_cpl_1_1_text_1_1_string.html" title="This abstract class defines the operations that can be before on a NULL terminated string.">String</a>' using a '<a class="el" href="class_cpl_1_1_text_1_1_d_f_string.html" title="This concrete class is a mix of FString and a DString - the initial memory is dynamically allocated -...">DFString</a>' as the internal storage for <a class="el" href="class_cpl_1_1_text_1_1_string.html" title="This abstract class defines the operations that can be before on a NULL terminated string.">String</a> instance.  <a href="class_cpl_1_1_text_1_1_d_f_string_item.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_cpl_1_1_text_1_1_d_string.html">DString</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">This concrete class implements a simple "dynamic storage" <a class="el" href="class_cpl_1_1_text_1_1_string.html" title="This abstract class defines the operations that can be before on a NULL terminated string.">String</a> <a class="el" href="namespace_cpl_1_1_type.html" title="The &#39;Cpl::Type&#39; namespace contain various typedefs and/or helper classes that function as general pur...">Type</a>.  <a href="class_cpl_1_1_text_1_1_d_string.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_cpl_1_1_text_1_1_d_string_item.html">DStringItem</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">This concrete class implements the <a class="el" href="class_cpl_1_1_text_1_1_string_item.html" title="This partially concrete provides a wrapper class that allows a String object to be stored directly in...">StringItem</a> class for a '<a class="el" href="class_cpl_1_1_text_1_1_string.html" title="This abstract class defines the operations that can be before on a NULL terminated string.">String</a>' using a '<a class="el" href="class_cpl_1_1_text_1_1_d_string.html" title="This concrete class implements a simple &quot;dynamic storage&quot; String Type.">DString</a>' as the internal storage for <a class="el" href="class_cpl_1_1_text_1_1_string.html" title="This abstract class defines the operations that can be before on a NULL terminated string.">String</a> instance.  <a href="class_cpl_1_1_text_1_1_d_string_item.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_cpl_1_1_text_1_1_f_string.html">FString</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">This template class represents a NULL terminated string of a specific length.  <a href="class_cpl_1_1_text_1_1_f_string.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_cpl_1_1_text_1_1_f_string__.html">FString_</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">This mostly concrete class implements a "fixed storage" <a class="el" href="class_cpl_1_1_text_1_1_string.html" title="This abstract class defines the operations that can be before on a NULL terminated string.">String</a> <a class="el" href="namespace_cpl_1_1_type.html" title="The &#39;Cpl::Type&#39; namespace contain various typedefs and/or helper classes that function as general pur...">Type</a>.  <a href="class_cpl_1_1_text_1_1_f_string__.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_cpl_1_1_text_1_1_f_string_item.html">FStringItem</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">This template class implements the <a class="el" href="class_cpl_1_1_text_1_1_string_item.html" title="This partially concrete provides a wrapper class that allows a String object to be stored directly in...">StringItem</a> class for a '<a class="el" href="class_cpl_1_1_text_1_1_string.html" title="This abstract class defines the operations that can be before on a NULL terminated string.">String</a>' using a '<a class="el" href="class_cpl_1_1_text_1_1_f_string.html" title="This template class represents a NULL terminated string of a specific length.">FString</a>' as the internal storage for <a class="el" href="class_cpl_1_1_text_1_1_string.html" title="This abstract class defines the operations that can be before on a NULL terminated string.">String</a> instance.  <a href="class_cpl_1_1_text_1_1_f_string_item.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_cpl_1_1_text_1_1_string.html">String</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">This abstract class defines the operations that can be before on a NULL terminated string.  <a href="class_cpl_1_1_text_1_1_string.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_cpl_1_1_text_1_1_string__.html">String_</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">This partially concrete class implements the portions of the <a class="el" href="class_cpl_1_1_text_1_1_string.html" title="This abstract class defines the operations that can be before on a NULL terminated string.">String</a> Api that is independent of the internal storage mechanisms.  <a href="class_cpl_1_1_text_1_1_string__.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_cpl_1_1_text_1_1_string_item.html">StringItem</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">This partially concrete provides a wrapper class that allows a <a class="el" href="class_cpl_1_1_text_1_1_string.html" title="This abstract class defines the operations that can be before on a NULL terminated string.">String</a> object to be stored directly in one the CPL Containers.  <a href="class_cpl_1_1_text_1_1_string_item.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a id="func-members" name="func-members"></a>
Functions</h2></td></tr>
<tr class="memitem:a7023b131150bf6e746c6eae38daf4294" id="r_a7023b131150bf6e746c6eae38daf4294"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a7023b131150bf6e746c6eae38daf4294">a2i</a> (int &amp;convertedValue, const char *string, int base=10, const char *validStopChars=0, const char **endptr=0)</td></tr>
<tr class="memdesc:a7023b131150bf6e746c6eae38daf4294"><td class="mdescLeft">&#160;</td><td class="mdescRight">This method converts the specified string to an integer.  <br /></td></tr>
<tr class="separator:a7023b131150bf6e746c6eae38daf4294"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5545e025ede3938fd5e326ea84a8d846" id="r_a5545e025ede3938fd5e326ea84a8d846"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a5545e025ede3938fd5e326ea84a8d846">a2ui</a> (unsigned &amp;convertedValue, const char *string, int base=10, const char *validStopChars=0, const char **endptr=0)</td></tr>
<tr class="memdesc:a5545e025ede3938fd5e326ea84a8d846"><td class="mdescLeft">&#160;</td><td class="mdescRight">This method is the same as <a class="el" href="#a7023b131150bf6e746c6eae38daf4294" title="This method converts the specified string to an integer.">a2i()</a> except that it converts unsigned integer.  <br /></td></tr>
<tr class="separator:a5545e025ede3938fd5e326ea84a8d846"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afb577681a19f3b6562acd0c3eb7095b4" id="r_afb577681a19f3b6562acd0c3eb7095b4"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#afb577681a19f3b6562acd0c3eb7095b4">a2l</a> (long &amp;convertedValue, const char *string, int base=10, const char *validStopChars=0, const char **endptr=0)</td></tr>
<tr class="memdesc:afb577681a19f3b6562acd0c3eb7095b4"><td class="mdescLeft">&#160;</td><td class="mdescRight">This method is the same as <a class="el" href="#a7023b131150bf6e746c6eae38daf4294" title="This method converts the specified string to an integer.">a2i()</a> except that it converts long integer.  <br /></td></tr>
<tr class="separator:afb577681a19f3b6562acd0c3eb7095b4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a06c830e654edfb12fac73cd26dcadfd7" id="r_a06c830e654edfb12fac73cd26dcadfd7"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a06c830e654edfb12fac73cd26dcadfd7">a2ul</a> (unsigned long &amp;convertedValue, const char *string, int base=10, const char *validStopChars=0, const char **endptr=0)</td></tr>
<tr class="memdesc:a06c830e654edfb12fac73cd26dcadfd7"><td class="mdescLeft">&#160;</td><td class="mdescRight">This method is the same as <a class="el" href="#a7023b131150bf6e746c6eae38daf4294" title="This method converts the specified string to an integer.">a2i()</a> except that it converts unsigned long integer.  <br /></td></tr>
<tr class="separator:a06c830e654edfb12fac73cd26dcadfd7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4912f3974cf06ae6e39c336473a81f3c" id="r_a4912f3974cf06ae6e39c336473a81f3c"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a4912f3974cf06ae6e39c336473a81f3c">a2ll</a> (long long &amp;convertedValue, const char *string, int base=10, const char *validStopChars=0, const char **endptr=0)</td></tr>
<tr class="memdesc:a4912f3974cf06ae6e39c336473a81f3c"><td class="mdescLeft">&#160;</td><td class="mdescRight">This method is the same as <a class="el" href="#a7023b131150bf6e746c6eae38daf4294" title="This method converts the specified string to an integer.">a2i()</a> except that it converts long long integer.  <br /></td></tr>
<tr class="separator:a4912f3974cf06ae6e39c336473a81f3c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0c51a67b6587ebfafe35ea064075d828" id="r_a0c51a67b6587ebfafe35ea064075d828"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a0c51a67b6587ebfafe35ea064075d828">a2ull</a> (unsigned long long &amp;convertedValue, const char *string, int base=10, const char *validStopChars=0, const char **endptr=0)</td></tr>
<tr class="memdesc:a0c51a67b6587ebfafe35ea064075d828"><td class="mdescLeft">&#160;</td><td class="mdescRight">This method is the same as <a class="el" href="#a7023b131150bf6e746c6eae38daf4294" title="This method converts the specified string to an integer.">a2i()</a> except that it converts unsigned long long integer.  <br /></td></tr>
<tr class="separator:a0c51a67b6587ebfafe35ea064075d828"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a926efe9ed5a7d87873a82fd377872d8d" id="r_a926efe9ed5a7d87873a82fd377872d8d"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a926efe9ed5a7d87873a82fd377872d8d">a2d</a> (double &amp;convertedValue, const char *string, const char *validStopChars=0, const char **endptr=0)</td></tr>
<tr class="memdesc:a926efe9ed5a7d87873a82fd377872d8d"><td class="mdescLeft">&#160;</td><td class="mdescRight">This method converts the specified string to an double.  <br /></td></tr>
<tr class="separator:a926efe9ed5a7d87873a82fd377872d8d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae1c0d2f2152fd16d950b7a44a3b7b1bd" id="r_ae1c0d2f2152fd16d950b7a44a3b7b1bd"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#ae1c0d2f2152fd16d950b7a44a3b7b1bd">a2b</a> (bool &amp;convertedValue, const char *string, const char *trueToken=&quot;T&quot;, const char *falseToken=&quot;F&quot;, const char **endptr=0)</td></tr>
<tr class="memdesc:ae1c0d2f2152fd16d950b7a44a3b7b1bd"><td class="mdescLeft">&#160;</td><td class="mdescRight">This method convert the specified string to an boolean.  <br /></td></tr>
<tr class="separator:ae1c0d2f2152fd16d950b7a44a3b7b1bd"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a02e148e7ecbd1c9368d8ee1a61984705" id="r_a02e148e7ecbd1c9368d8ee1a61984705"><td class="memItemLeft" align="right" valign="top">long&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a02e148e7ecbd1c9368d8ee1a61984705">asciiHexToBuffer</a> (void *dstBinary, const char *srcString, size_t dstMaxLen)</td></tr>
<tr class="memdesc:a02e148e7ecbd1c9368d8ee1a61984705"><td class="mdescLeft">&#160;</td><td class="mdescRight">This method will convert an 'ASCII HEX' string to an equivalent binary buffer, i.e.  <br /></td></tr>
<tr class="separator:a02e148e7ecbd1c9368d8ee1a61984705"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0080597eb0b1ef27c6872cfb5fc4e32d" id="r_a0080597eb0b1ef27c6872cfb5fc4e32d"><td class="memItemLeft" align="right" valign="top">long&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a0080597eb0b1ef27c6872cfb5fc4e32d">asciiBinaryToBuffer</a> (void *dstBinary, const char *srcString, size_t dstMaxLen, bool reverse=false)</td></tr>
<tr class="memdesc:a0080597eb0b1ef27c6872cfb5fc4e32d"><td class="mdescLeft">&#160;</td><td class="mdescRight">This method will convert an 'ASCII BINARY' string to an equivalent binary buffer, i.e.  <br /></td></tr>
<tr class="separator:a0080597eb0b1ef27c6872cfb5fc4e32d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a365931bdae91b7355a26372e042889f4" id="r_a365931bdae91b7355a26372e042889f4"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a365931bdae91b7355a26372e042889f4">parsePrecisionTimeStamp</a> (const char *timeStampToParse, <a class="el" href="struct_cpl_1_1_system_1_1_elapsed_time_1_1_precision___t.html">Cpl::System::ElapsedTime::Precision_T</a> &amp;convertedValue)</td></tr>
<tr class="memdesc:a365931bdae91b7355a26372e042889f4"><td class="mdescLeft">&#160;</td><td class="mdescRight">This method parses a 'timestamp' with the following format: [DD ]HH:MM:SS[.sss] The method returns true if the parse was successful.  <br /></td></tr>
<tr class="separator:a365931bdae91b7355a26372e042889f4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa3c0120748c5f361021e6032eea64eeb" id="r_aa3c0120748c5f361021e6032eea64eeb"><td class="memItemLeft" align="right" valign="top">const char *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#aa3c0120748c5f361021e6032eea64eeb">longToStr</a> (long num, char *dstString, size_t maxChars, unsigned base=10, char padChar=' ')</td></tr>
<tr class="memdesc:aa3c0120748c5f361021e6032eea64eeb"><td class="mdescLeft">&#160;</td><td class="mdescRight">This method converts a long to a string.  <br /></td></tr>
<tr class="separator:aa3c0120748c5f361021e6032eea64eeb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a744cb16fbbf617dc1cdbb8fbd77feff8" id="r_a744cb16fbbf617dc1cdbb8fbd77feff8"><td class="memItemLeft" align="right" valign="top">const char *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a744cb16fbbf617dc1cdbb8fbd77feff8">ulongToStr</a> (unsigned long num, char *dstString, size_t maxChars, unsigned base=10, char padChar=' ')</td></tr>
<tr class="memdesc:a744cb16fbbf617dc1cdbb8fbd77feff8"><td class="mdescLeft">&#160;</td><td class="mdescRight">This method is same as <a class="el" href="#aa3c0120748c5f361021e6032eea64eeb" title="This method converts a long to a string.">longToStr()</a>, except it converts a unsigned long value.  <br /></td></tr>
<tr class="separator:a744cb16fbbf617dc1cdbb8fbd77feff8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a062afbbf06902a24f6b7ccb6e29f673f" id="r_a062afbbf06902a24f6b7ccb6e29f673f"><td class="memItemLeft" align="right" valign="top">const char *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a062afbbf06902a24f6b7ccb6e29f673f">sizetToStr</a> (size_t num, char *dstString, size_t maxChars, unsigned base=10, char padChar=' ')</td></tr>
<tr class="memdesc:a062afbbf06902a24f6b7ccb6e29f673f"><td class="mdescLeft">&#160;</td><td class="mdescRight">This method is same as <a class="el" href="#aa3c0120748c5f361021e6032eea64eeb" title="This method converts a long to a string.">longToStr()</a>, except it converts a size_t value.  <br /></td></tr>
<tr class="separator:a062afbbf06902a24f6b7ccb6e29f673f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a958036b6c1d71de588912e2ee2e1cfa6" id="r_a958036b6c1d71de588912e2ee2e1cfa6"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a958036b6c1d71de588912e2ee2e1cfa6">bufferToString</a> (const void *buffer, int len, <a class="el" href="class_cpl_1_1_text_1_1_string.html">Cpl::Text::String</a> &amp;destString, bool appendToString=false)</td></tr>
<tr class="memdesc:a958036b6c1d71de588912e2ee2e1cfa6"><td class="mdescLeft">&#160;</td><td class="mdescRight">This method will take a raw data buffer and convert it to an 'viewable' string.  <br /></td></tr>
<tr class="separator:a958036b6c1d71de588912e2ee2e1cfa6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af5e325a101f50cf33c571e320d826304" id="r_af5e325a101f50cf33c571e320d826304"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#af5e325a101f50cf33c571e320d826304">bufferToAsciiHex</a> (const void *binaryData, int len, <a class="el" href="class_cpl_1_1_text_1_1_string.html">Cpl::Text::String</a> &amp;destString, bool upperCase=true, bool appendToString=false, char separator='\0')</td></tr>
<tr class="memdesc:af5e325a101f50cf33c571e320d826304"><td class="mdescLeft">&#160;</td><td class="mdescRight">This method will convert a binary buffer to 'ASCII HEX', e.g.  <br /></td></tr>
<tr class="separator:af5e325a101f50cf33c571e320d826304"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4987ae229f3c5126f48217684c2f62d3" id="r_a4987ae229f3c5126f48217684c2f62d3"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a4987ae229f3c5126f48217684c2f62d3">bufferToAsciiBinary</a> (const void *binaryData, int len, <a class="el" href="class_cpl_1_1_text_1_1_string.html">Cpl::Text::String</a> &amp;destString, bool appendToString=false, bool reverse=false)</td></tr>
<tr class="memdesc:a4987ae229f3c5126f48217684c2f62d3"><td class="mdescLeft">&#160;</td><td class="mdescRight">This method converts the binary buffer to a single string that is ASCII BINARY.  <br /></td></tr>
<tr class="separator:a4987ae229f3c5126f48217684c2f62d3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a403a805821f2721d0433e6d9e262cc63" id="r_a403a805821f2721d0433e6d9e262cc63"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a403a805821f2721d0433e6d9e262cc63">bufferToViewer</a> (const void *binaryData, int len, <a class="el" href="class_cpl_1_1_text_1_1_string.html">Cpl::Text::String</a> &amp;destString, int bytesPerLine=16, const char *separator=&quot;    &quot;, bool upperCase=true, bool appendToString=false)</td></tr>
<tr class="memdesc:a403a805821f2721d0433e6d9e262cc63"><td class="mdescLeft">&#160;</td><td class="mdescRight">This method converts the binary buffer to a single string that is the ASCII HEX followed by 'separator', then by the binary data as 'viewable' text.  <br /></td></tr>
<tr class="separator:a403a805821f2721d0433e6d9e262cc63"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac81a7c3db0fdf1ece0a09bdb73ef8e9c" id="r_ac81a7c3db0fdf1ece0a09bdb73ef8e9c"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#ac81a7c3db0fdf1ece0a09bdb73ef8e9c">formatMsecTimeStamp</a> (<a class="el" href="class_cpl_1_1_text_1_1_string.html">Cpl::Text::String</a> &amp;buffer, unsigned long long timeStampInMsecs, bool encodeDay=true, bool appendToString=false)</td></tr>
<tr class="memdesc:ac81a7c3db0fdf1ece0a09bdb73ef8e9c"><td class="mdescLeft">&#160;</td><td class="mdescRight">This method converts the binary millisecond count of 'timeStampInMsecs' to a string with the following format: "DD HH:MM:SS.SSS".  <br /></td></tr>
<tr class="separator:ac81a7c3db0fdf1ece0a09bdb73ef8e9c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab519c3ecf8ad77149f44dc41ef73f843" id="r_ab519c3ecf8ad77149f44dc41ef73f843"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#ab519c3ecf8ad77149f44dc41ef73f843">formatSecTimeStamp</a> (<a class="el" href="class_cpl_1_1_text_1_1_string.html">Cpl::Text::String</a> &amp;buffer, unsigned long long timeStampInSecs, bool encodeDay=true, bool appendToString=false)</td></tr>
<tr class="memdesc:ab519c3ecf8ad77149f44dc41ef73f843"><td class="mdescLeft">&#160;</td><td class="mdescRight">This method converts the binary second count of 'timeStampInSecs' to a string with the following format: "DD HH:MM:SS".  <br /></td></tr>
<tr class="separator:ab519c3ecf8ad77149f44dc41ef73f843"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a58a2435abd2d2b7393fbc4bf0f4eba2f" id="r_a58a2435abd2d2b7393fbc4bf0f4eba2f"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a58a2435abd2d2b7393fbc4bf0f4eba2f">formatPrecisionTimeStamp</a> (<a class="el" href="class_cpl_1_1_text_1_1_string.html">Cpl::Text::String</a> &amp;buffer, <a class="el" href="struct_cpl_1_1_system_1_1_elapsed_time_1_1_precision___t.html">Cpl::System::ElapsedTime::Precision_T</a> timeStamp, bool encodeDay=true, bool appendToString=false)</td></tr>
<tr class="memdesc:a58a2435abd2d2b7393fbc4bf0f4eba2f"><td class="mdescLeft">&#160;</td><td class="mdescRight">This method converts the <a class="el" href="struct_cpl_1_1_system_1_1_elapsed_time_1_1_precision___t.html" title="Data type for time in seconds with a &#39;fractional&#39; millisecond precision.">Cpl::System::ElapsedTime::Precision_T</a> value of time into a string with the following format: "DD HH:MM:SS.SSS".  <br /></td></tr>
<tr class="separator:a58a2435abd2d2b7393fbc4bf0f4eba2f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae63c1c1fb47d22a4cf298bb8b70c6a23" id="r_ae63c1c1fb47d22a4cf298bb8b70c6a23"><td class="memItemLeft" align="right" valign="top">uint8_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#ae63c1c1fb47d22a4cf298bb8b70c6a23">unhexChar</a> (char c)</td></tr>
<tr class="memdesc:ae63c1c1fb47d22a4cf298bb8b70c6a23"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the binary value for the 'ASCII HEX' character 'c'.  <br /></td></tr>
<tr class="separator:ae63c1c1fb47d22a4cf298bb8b70c6a23"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4c50715706396ff46bd0b67c442d189a" id="r_a4c50715706396ff46bd0b67c442d189a"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a4c50715706396ff46bd0b67c442d189a">unhex</a> (const char *inString, size_t numCharToScan, uint8_t *outData)</td></tr>
<tr class="memdesc:a4c50715706396ff46bd0b67c442d189a"><td class="mdescLeft">&#160;</td><td class="mdescRight">This method converts up to 'numCharToScan' characters from the ASCII HEX text string.  <br /></td></tr>
<tr class="separator:a4c50715706396ff46bd0b67c442d189a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6c8b46bf0a7d779aba99690eb0edde40" id="r_a6c8b46bf0a7d779aba99690eb0edde40"><td class="memItemLeft" align="right" valign="top">const char *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a6c8b46bf0a7d779aba99690eb0edde40">stripSpace</a> (const char *s)</td></tr>
<tr class="memdesc:a6c8b46bf0a7d779aba99690eb0edde40"><td class="mdescLeft">&#160;</td><td class="mdescRight">This method returns a pointer to the FIRST non-whitespace character in the the specified null-terminated string.  <br /></td></tr>
<tr class="separator:a6c8b46bf0a7d779aba99690eb0edde40"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab98b55d59f1d0e43d4885d9acc3beb37" id="r_ab98b55d59f1d0e43d4885d9acc3beb37"><td class="memItemLeft" align="right" valign="top">const char *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#ab98b55d59f1d0e43d4885d9acc3beb37">stripNotSpace</a> (const char *s)</td></tr>
<tr class="memdesc:ab98b55d59f1d0e43d4885d9acc3beb37"><td class="mdescLeft">&#160;</td><td class="mdescRight">This method returns a pointer to the FIRST whitespace character in the the specified null-terminated string.  <br /></td></tr>
<tr class="separator:ab98b55d59f1d0e43d4885d9acc3beb37"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:addf14c7fbc3870724da378fc9da00cdf" id="r_addf14c7fbc3870724da378fc9da00cdf"><td class="memItemLeft" align="right" valign="top">const char *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#addf14c7fbc3870724da378fc9da00cdf">stripTrailingSpace</a> (const char *s)</td></tr>
<tr class="memdesc:addf14c7fbc3870724da378fc9da00cdf"><td class="mdescLeft">&#160;</td><td class="mdescRight">This method returns a pointer to the LAST non-whitespace character in the the specified null-terminated string.  <br /></td></tr>
<tr class="separator:addf14c7fbc3870724da378fc9da00cdf"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af1cb01066ac4701cb10670ee4325e44b" id="r_af1cb01066ac4701cb10670ee4325e44b"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#af1cb01066ac4701cb10670ee4325e44b">removeTrailingSpace</a> (char *s)</td></tr>
<tr class="memdesc:af1cb01066ac4701cb10670ee4325e44b"><td class="mdescLeft">&#160;</td><td class="mdescRight">This method TRUNCATES the specified null-terminated string by eliminating any trailing white space.  <br /></td></tr>
<tr class="separator:af1cb01066ac4701cb10670ee4325e44b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a99cac4baaf9aaa9f235b8d290ff002dc" id="r_a99cac4baaf9aaa9f235b8d290ff002dc"><td class="memItemLeft" align="right" valign="top">const char *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a99cac4baaf9aaa9f235b8d290ff002dc">stripChars</a> (const char *s, const char *charsSet)</td></tr>
<tr class="memdesc:a99cac4baaf9aaa9f235b8d290ff002dc"><td class="mdescLeft">&#160;</td><td class="mdescRight">This method is the same as <a class="el" href="#a6c8b46bf0a7d779aba99690eb0edde40" title="This method returns a pointer to the FIRST non-whitespace character in the the specified null-termina...">stripSpace()</a>, except the specified character set is used to terminate the search instead of the standard isspace() characters.  <br /></td></tr>
<tr class="separator:a99cac4baaf9aaa9f235b8d290ff002dc"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae54c3fb5390a704e286863ab25c2dff6" id="r_ae54c3fb5390a704e286863ab25c2dff6"><td class="memItemLeft" align="right" valign="top">const char *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#ae54c3fb5390a704e286863ab25c2dff6">stripNotChars</a> (const char *s, const char *charsSet)</td></tr>
<tr class="memdesc:ae54c3fb5390a704e286863ab25c2dff6"><td class="mdescLeft">&#160;</td><td class="mdescRight">This method is the same as <a class="el" href="#ab98b55d59f1d0e43d4885d9acc3beb37" title="This method returns a pointer to the FIRST whitespace character in the the specified null-terminated ...">stripNotSpace()</a>, except the specified character set is used to terminate the search instead of the standard isspace() characters.  <br /></td></tr>
<tr class="separator:ae54c3fb5390a704e286863ab25c2dff6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a462b96d5d7456b0e284e94de1736fb3b" id="r_a462b96d5d7456b0e284e94de1736fb3b"><td class="memItemLeft" align="right" valign="top">const char *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a462b96d5d7456b0e284e94de1736fb3b">stripTrailingChars</a> (const char *s, const char *charsSet)</td></tr>
<tr class="memdesc:a462b96d5d7456b0e284e94de1736fb3b"><td class="mdescLeft">&#160;</td><td class="mdescRight">This method is the same as stripTrailingSpaces(), except the specified character set is used to identify the last "non-whitespace" character.  <br /></td></tr>
<tr class="separator:a462b96d5d7456b0e284e94de1736fb3b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aae9a2f33932dfaa319c5eb23b36fe8de" id="r_aae9a2f33932dfaa319c5eb23b36fe8de"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#aae9a2f33932dfaa319c5eb23b36fe8de">removeTrailingChars</a> (char *s, const char *charsSet)</td></tr>
<tr class="memdesc:aae9a2f33932dfaa319c5eb23b36fe8de"><td class="mdescLeft">&#160;</td><td class="mdescRight">This method is the same as removeTrailingSpaces(), except the specified characters set is used for "whitespace" any trailing white space.  <br /></td></tr>
<tr class="separator:aae9a2f33932dfaa319c5eb23b36fe8de"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3f46f4bb0cba3cd95b91d1c1f639eabe" id="r_a3f46f4bb0cba3cd95b91d1c1f639eabe"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a3f46f4bb0cba3cd95b91d1c1f639eabe">isCharInString</a> (const char *charsSet, const char c)</td></tr>
<tr class="memdesc:a3f46f4bb0cba3cd95b91d1c1f639eabe"><td class="mdescLeft">&#160;</td><td class="mdescRight">This method returns true if the character 'c' is one of character(s) contained in 'charsSet'; else false is returned.  <br /></td></tr>
<tr class="separator:a3f46f4bb0cba3cd95b91d1c1f639eabe"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<h2 class="groupheader">Function Documentation</h2>
<a id="ae1c0d2f2152fd16d950b7a44a3b7b1bd" name="ae1c0d2f2152fd16d950b7a44a3b7b1bd"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae1c0d2f2152fd16d950b7a44a3b7b1bd">&#9670;&#160;</a></span>a2b()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool Cpl::Text::a2b </td>
          <td>(</td>
          <td class="paramtype">bool &amp;</td>          <td class="paramname"><span class="paramname"><em>convertedValue</em>, </span></td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *</td>          <td class="paramname"><span class="paramname"><em>string</em>, </span></td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *</td>          <td class="paramname"><span class="paramname"><em>trueToken</em><span class="paramdefsep"> = </span><span class="paramdefval">&quot;T&quot;</span>, </span></td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *</td>          <td class="paramname"><span class="paramname"><em>falseToken</em><span class="paramdefsep"> = </span><span class="paramdefval">&quot;F&quot;</span>, </span></td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char **</td>          <td class="paramname"><span class="paramname"><em>endptr</em><span class="paramdefsep"> = </span><span class="paramdefval">0</span></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>This method convert the specified string to an boolean. </p>
<p>The method returns true if the conversion was successful. When false is returned, the 'convertedValue' argument is NOT updated. If the first N characters of 'string' match the specified boolean token - the conversion is consider successful (i.e. there is no required separator/terminator character for a boolean token). If endptr is specified and the method returns true, a pointer to the first character 'after' the boolean token is returned. </p>

</div>
</div>
<a id="a926efe9ed5a7d87873a82fd377872d8d" name="a926efe9ed5a7d87873a82fd377872d8d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a926efe9ed5a7d87873a82fd377872d8d">&#9670;&#160;</a></span>a2d()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool Cpl::Text::a2d </td>
          <td>(</td>
          <td class="paramtype">double &amp;</td>          <td class="paramname"><span class="paramname"><em>convertedValue</em>, </span></td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *</td>          <td class="paramname"><span class="paramname"><em>string</em>, </span></td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *</td>          <td class="paramname"><span class="paramname"><em>validStopChars</em><span class="paramdefsep"> = </span><span class="paramdefval">0</span>, </span></td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char **</td>          <td class="paramname"><span class="paramname"><em>endptr</em><span class="paramdefsep"> = </span><span class="paramdefval">0</span></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>This method converts the specified string to an double. </p>
<p>The method returns true if the conversion was successful. When false is returned, the 'convertedValue' argument is NOT updated. By default the conversion assumes that the 'end-of-number' is end-of-string. If endptr is specified and the method returns true, a pointer to the first character 'after' the number is returned. </p>

</div>
</div>
<a id="a7023b131150bf6e746c6eae38daf4294" name="a7023b131150bf6e746c6eae38daf4294"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7023b131150bf6e746c6eae38daf4294">&#9670;&#160;</a></span>a2i()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool Cpl::Text::a2i </td>
          <td>(</td>
          <td class="paramtype">int &amp;</td>          <td class="paramname"><span class="paramname"><em>convertedValue</em>, </span></td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *</td>          <td class="paramname"><span class="paramname"><em>string</em>, </span></td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int</td>          <td class="paramname"><span class="paramname"><em>base</em><span class="paramdefsep"> = </span><span class="paramdefval">10</span>, </span></td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *</td>          <td class="paramname"><span class="paramname"><em>validStopChars</em><span class="paramdefsep"> = </span><span class="paramdefval">0</span>, </span></td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char **</td>          <td class="paramname"><span class="paramname"><em>endptr</em><span class="paramdefsep"> = </span><span class="paramdefval">0</span></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>This method converts the specified string to an integer. </p>
<p>The method returns true if the conversion was successful. When false is returned, the 'convertedValue' argument is NOT updated. By default the conversion assumes a base 10 number and that the 'end-of-number' is end-of-string. If endptr is specified and the conversation was successful, a pointer to the first character 'after' the number is returned. </p>

</div>
</div>
<a id="afb577681a19f3b6562acd0c3eb7095b4" name="afb577681a19f3b6562acd0c3eb7095b4"></a>
<h2 class="memtitle"><span class="permalink"><a href="#afb577681a19f3b6562acd0c3eb7095b4">&#9670;&#160;</a></span>a2l()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool Cpl::Text::a2l </td>
          <td>(</td>
          <td class="paramtype">long &amp;</td>          <td class="paramname"><span class="paramname"><em>convertedValue</em>, </span></td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *</td>          <td class="paramname"><span class="paramname"><em>string</em>, </span></td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int</td>          <td class="paramname"><span class="paramname"><em>base</em><span class="paramdefsep"> = </span><span class="paramdefval">10</span>, </span></td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *</td>          <td class="paramname"><span class="paramname"><em>validStopChars</em><span class="paramdefsep"> = </span><span class="paramdefval">0</span>, </span></td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char **</td>          <td class="paramname"><span class="paramname"><em>endptr</em><span class="paramdefsep"> = </span><span class="paramdefval">0</span></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>This method is the same as <a class="el" href="#a7023b131150bf6e746c6eae38daf4294" title="This method converts the specified string to an integer.">a2i()</a> except that it converts long integer. </p>

</div>
</div>
<a id="a4912f3974cf06ae6e39c336473a81f3c" name="a4912f3974cf06ae6e39c336473a81f3c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a4912f3974cf06ae6e39c336473a81f3c">&#9670;&#160;</a></span>a2ll()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool Cpl::Text::a2ll </td>
          <td>(</td>
          <td class="paramtype">long long &amp;</td>          <td class="paramname"><span class="paramname"><em>convertedValue</em>, </span></td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *</td>          <td class="paramname"><span class="paramname"><em>string</em>, </span></td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int</td>          <td class="paramname"><span class="paramname"><em>base</em><span class="paramdefsep"> = </span><span class="paramdefval">10</span>, </span></td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *</td>          <td class="paramname"><span class="paramname"><em>validStopChars</em><span class="paramdefsep"> = </span><span class="paramdefval">0</span>, </span></td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char **</td>          <td class="paramname"><span class="paramname"><em>endptr</em><span class="paramdefsep"> = </span><span class="paramdefval">0</span></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>This method is the same as <a class="el" href="#a7023b131150bf6e746c6eae38daf4294" title="This method converts the specified string to an integer.">a2i()</a> except that it converts long long integer. </p>

</div>
</div>
<a id="a5545e025ede3938fd5e326ea84a8d846" name="a5545e025ede3938fd5e326ea84a8d846"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5545e025ede3938fd5e326ea84a8d846">&#9670;&#160;</a></span>a2ui()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool Cpl::Text::a2ui </td>
          <td>(</td>
          <td class="paramtype">unsigned &amp;</td>          <td class="paramname"><span class="paramname"><em>convertedValue</em>, </span></td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *</td>          <td class="paramname"><span class="paramname"><em>string</em>, </span></td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int</td>          <td class="paramname"><span class="paramname"><em>base</em><span class="paramdefsep"> = </span><span class="paramdefval">10</span>, </span></td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *</td>          <td class="paramname"><span class="paramname"><em>validStopChars</em><span class="paramdefsep"> = </span><span class="paramdefval">0</span>, </span></td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char **</td>          <td class="paramname"><span class="paramname"><em>endptr</em><span class="paramdefsep"> = </span><span class="paramdefval">0</span></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>This method is the same as <a class="el" href="#a7023b131150bf6e746c6eae38daf4294" title="This method converts the specified string to an integer.">a2i()</a> except that it converts unsigned integer. </p>

</div>
</div>
<a id="a06c830e654edfb12fac73cd26dcadfd7" name="a06c830e654edfb12fac73cd26dcadfd7"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a06c830e654edfb12fac73cd26dcadfd7">&#9670;&#160;</a></span>a2ul()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool Cpl::Text::a2ul </td>
          <td>(</td>
          <td class="paramtype">unsigned long &amp;</td>          <td class="paramname"><span class="paramname"><em>convertedValue</em>, </span></td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *</td>          <td class="paramname"><span class="paramname"><em>string</em>, </span></td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int</td>          <td class="paramname"><span class="paramname"><em>base</em><span class="paramdefsep"> = </span><span class="paramdefval">10</span>, </span></td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *</td>          <td class="paramname"><span class="paramname"><em>validStopChars</em><span class="paramdefsep"> = </span><span class="paramdefval">0</span>, </span></td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char **</td>          <td class="paramname"><span class="paramname"><em>endptr</em><span class="paramdefsep"> = </span><span class="paramdefval">0</span></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>This method is the same as <a class="el" href="#a7023b131150bf6e746c6eae38daf4294" title="This method converts the specified string to an integer.">a2i()</a> except that it converts unsigned long integer. </p>

</div>
</div>
<a id="a0c51a67b6587ebfafe35ea064075d828" name="a0c51a67b6587ebfafe35ea064075d828"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0c51a67b6587ebfafe35ea064075d828">&#9670;&#160;</a></span>a2ull()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool Cpl::Text::a2ull </td>
          <td>(</td>
          <td class="paramtype">unsigned long long &amp;</td>          <td class="paramname"><span class="paramname"><em>convertedValue</em>, </span></td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *</td>          <td class="paramname"><span class="paramname"><em>string</em>, </span></td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int</td>          <td class="paramname"><span class="paramname"><em>base</em><span class="paramdefsep"> = </span><span class="paramdefval">10</span>, </span></td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *</td>          <td class="paramname"><span class="paramname"><em>validStopChars</em><span class="paramdefsep"> = </span><span class="paramdefval">0</span>, </span></td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char **</td>          <td class="paramname"><span class="paramname"><em>endptr</em><span class="paramdefsep"> = </span><span class="paramdefval">0</span></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>This method is the same as <a class="el" href="#a7023b131150bf6e746c6eae38daf4294" title="This method converts the specified string to an integer.">a2i()</a> except that it converts unsigned long long integer. </p>

</div>
</div>
<a id="a0080597eb0b1ef27c6872cfb5fc4e32d" name="a0080597eb0b1ef27c6872cfb5fc4e32d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0080597eb0b1ef27c6872cfb5fc4e32d">&#9670;&#160;</a></span>asciiBinaryToBuffer()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">long Cpl::Text::asciiBinaryToBuffer </td>
          <td>(</td>
          <td class="paramtype">void *</td>          <td class="paramname"><span class="paramname"><em>dstBinary</em>, </span></td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *</td>          <td class="paramname"><span class="paramname"><em>srcString</em>, </span></td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t</td>          <td class="paramname"><span class="paramname"><em>dstMaxLen</em>, </span></td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool</td>          <td class="paramname"><span class="paramname"><em>reverse</em><span class="paramdefsep"> = </span><span class="paramdefval">false</span></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>This method will convert an 'ASCII BINARY' string to an equivalent binary buffer, i.e. </p>
<p>the reverse of <a class="el" href="#a4987ae229f3c5126f48217684c2f62d3" title="This method converts the binary buffer to a single string that is ASCII BINARY.">bufferToAsciiBinary()</a> in <a class="el" href="format_8h.html" title="This file contains some general purpose string formatting functions.">format.h</a>. The 'reverse' argument when set to true will store the binary data starting with the last byte of 'dstBinary'.</p>
<p>If the number of '1' and '0' in 'srcString' is not a multiple of eight - the 'missing' bits will be set to zero in the binary output.</p>
<p>If the entire string was not able to be converted then -1 is returned OR if there are non '1'/'0' characters in the srcString; else the number of converted bits are returned. <br  />
</p>
<p>Note: 'srcString' MUST be a null terminated string </p>

</div>
</div>
<a id="a02e148e7ecbd1c9368d8ee1a61984705" name="a02e148e7ecbd1c9368d8ee1a61984705"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a02e148e7ecbd1c9368d8ee1a61984705">&#9670;&#160;</a></span>asciiHexToBuffer()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">long Cpl::Text::asciiHexToBuffer </td>
          <td>(</td>
          <td class="paramtype">void *</td>          <td class="paramname"><span class="paramname"><em>dstBinary</em>, </span></td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *</td>          <td class="paramname"><span class="paramname"><em>srcString</em>, </span></td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t</td>          <td class="paramname"><span class="paramname"><em>dstMaxLen</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>This method will convert an 'ASCII HEX' string to an equivalent binary buffer, i.e. </p>
<p>the reverse of <a class="el" href="#af5e325a101f50cf33c571e320d826304" title="This method will convert a binary buffer to &#39;ASCII HEX&#39;, e.g.">bufferToAsciiHex()</a> in <a class="el" href="format_8h.html" title="This file contains some general purpose string formatting functions.">format.h</a>. If the entire string was not able to be converted then -1 is returned, else the number of converted bytes are returned. </p>

</div>
</div>
<a id="a4987ae229f3c5126f48217684c2f62d3" name="a4987ae229f3c5126f48217684c2f62d3"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a4987ae229f3c5126f48217684c2f62d3">&#9670;&#160;</a></span>bufferToAsciiBinary()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool Cpl::Text::bufferToAsciiBinary </td>
          <td>(</td>
          <td class="paramtype">const void *</td>          <td class="paramname"><span class="paramname"><em>binaryData</em>, </span></td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int</td>          <td class="paramname"><span class="paramname"><em>len</em>, </span></td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="class_cpl_1_1_text_1_1_string.html">Cpl::Text::String</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>destString</em>, </span></td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool</td>          <td class="paramname"><span class="paramname"><em>appendToString</em><span class="paramdefsep"> = </span><span class="paramdefval">false</span>, </span></td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool</td>          <td class="paramname"><span class="paramname"><em>reverse</em><span class="paramdefsep"> = </span><span class="paramdefval">false</span></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>This method converts the binary buffer to a single string that is ASCII BINARY. </p>
<p>The number of digits in the output string is always a multiple of</p><ol type="1">
<li>The default order for traversing the 'binaryData' is to start with binaryData[0].</li>
</ol>
<p>The converted result is returned via 'buffer'. If the results where truncated by the no enough memory in 'buffer' then false is returned; else true is returned. <br  />
</p>
<p>Examples: binaryData = 0x844A, reverse=false, destString = "1000010001001010" binaryData = 0x844A, reverse=true, destString = "0100101010000100" </p>

</div>
</div>
<a id="af5e325a101f50cf33c571e320d826304" name="af5e325a101f50cf33c571e320d826304"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af5e325a101f50cf33c571e320d826304">&#9670;&#160;</a></span>bufferToAsciiHex()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool Cpl::Text::bufferToAsciiHex </td>
          <td>(</td>
          <td class="paramtype">const void *</td>          <td class="paramname"><span class="paramname"><em>binaryData</em>, </span></td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int</td>          <td class="paramname"><span class="paramname"><em>len</em>, </span></td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="class_cpl_1_1_text_1_1_string.html">Cpl::Text::String</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>destString</em>, </span></td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool</td>          <td class="paramname"><span class="paramname"><em>upperCase</em><span class="paramdefsep"> = </span><span class="paramdefval">true</span>, </span></td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool</td>          <td class="paramname"><span class="paramname"><em>appendToString</em><span class="paramdefsep"> = </span><span class="paramdefval">false</span>, </span></td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">char</td>          <td class="paramname"><span class="paramname"><em>separator</em><span class="paramdefsep"> = </span><span class="paramdefval">'\0'</span></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>This method will convert a binary buffer to 'ASCII HEX', e.g. </p>
<p>given the binary data of { 12, F2, 54 }, destString:= "12F254". The method will return true if buffer was successfully converted, i.e. the ENTIRE buffer was converted to a string; else false is returned (this include the cases of null 'buffer' pointer, 'len' equals zero, or not enough memory in 'destString' to contain the final result).</p>
<p>If 'separator' does not equal '\0', then it inserted between bytes in the output string.</p>
<p>Note: The default operation is to use uppercase text and to clear the destString before the conversion. </p>

</div>
</div>
<a id="a958036b6c1d71de588912e2ee2e1cfa6" name="a958036b6c1d71de588912e2ee2e1cfa6"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a958036b6c1d71de588912e2ee2e1cfa6">&#9670;&#160;</a></span>bufferToString()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool Cpl::Text::bufferToString </td>
          <td>(</td>
          <td class="paramtype">const void *</td>          <td class="paramname"><span class="paramname"><em>buffer</em>, </span></td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int</td>          <td class="paramname"><span class="paramname"><em>len</em>, </span></td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="class_cpl_1_1_text_1_1_string.html">Cpl::Text::String</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>destString</em>, </span></td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool</td>          <td class="paramname"><span class="paramname"><em>appendToString</em><span class="paramdefsep"> = </span><span class="paramdefval">false</span></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>This method will take a raw data buffer and convert it to an 'viewable' string. </p>
<p>Non-printable values will displayed as '.'. Note: The default operation is to clear the destString before the conversion. The method will return if buffer was successfully converted, i.e. the ENTIRE buffer was converted; else false is returned (this include the cases of null 'buffer' pointer, 'len' equals zero, or not enough memory in 'destString' to contain the final result). </p>

</div>
</div>
<a id="a403a805821f2721d0433e6d9e262cc63" name="a403a805821f2721d0433e6d9e262cc63"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a403a805821f2721d0433e6d9e262cc63">&#9670;&#160;</a></span>bufferToViewer()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool Cpl::Text::bufferToViewer </td>
          <td>(</td>
          <td class="paramtype">const void *</td>          <td class="paramname"><span class="paramname"><em>binaryData</em>, </span></td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int</td>          <td class="paramname"><span class="paramname"><em>len</em>, </span></td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="class_cpl_1_1_text_1_1_string.html">Cpl::Text::String</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>destString</em>, </span></td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int</td>          <td class="paramname"><span class="paramname"><em>bytesPerLine</em><span class="paramdefsep"> = </span><span class="paramdefval">16</span>, </span></td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *</td>          <td class="paramname"><span class="paramname"><em>separator</em><span class="paramdefsep"> = </span><span class="paramdefval">&quot;&#160;&#160;&#160;&#160;&quot;</span>, </span></td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool</td>          <td class="paramname"><span class="paramname"><em>upperCase</em><span class="paramdefsep"> = </span><span class="paramdefval">true</span>, </span></td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool</td>          <td class="paramname"><span class="paramname"><em>appendToString</em><span class="paramdefsep"> = </span><span class="paramdefval">false</span></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>This method converts the binary buffer to a single string that is the ASCII HEX followed by 'separator', then by the binary data as 'viewable' text. </p>
<p>The converted result is returned via 'buffer'. If the results where truncated by the no enough memory in 'buffer' then false is returned; else true is returned. </p>

</div>
</div>
<a id="ac81a7c3db0fdf1ece0a09bdb73ef8e9c" name="ac81a7c3db0fdf1ece0a09bdb73ef8e9c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac81a7c3db0fdf1ece0a09bdb73ef8e9c">&#9670;&#160;</a></span>formatMsecTimeStamp()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool Cpl::Text::formatMsecTimeStamp </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="class_cpl_1_1_text_1_1_string.html">Cpl::Text::String</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>buffer</em>, </span></td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned long long</td>          <td class="paramname"><span class="paramname"><em>timeStampInMsecs</em>, </span></td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool</td>          <td class="paramname"><span class="paramname"><em>encodeDay</em><span class="paramdefsep"> = </span><span class="paramdefval">true</span>, </span></td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool</td>          <td class="paramname"><span class="paramname"><em>appendToString</em><span class="paramdefsep"> = </span><span class="paramdefval">false</span></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>This method converts the binary millisecond count of 'timeStampInMsecs' to a string with the following format: "DD HH:MM:SS.SSS". </p>
<p>The converted result is returned via 'buffer'. If the results where truncated by the no enough memory in 'buffer' then false is returned; else true is returned. </p>

</div>
</div>
<a id="a58a2435abd2d2b7393fbc4bf0f4eba2f" name="a58a2435abd2d2b7393fbc4bf0f4eba2f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a58a2435abd2d2b7393fbc4bf0f4eba2f">&#9670;&#160;</a></span>formatPrecisionTimeStamp()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool Cpl::Text::formatPrecisionTimeStamp </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="class_cpl_1_1_text_1_1_string.html">Cpl::Text::String</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>buffer</em>, </span></td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="struct_cpl_1_1_system_1_1_elapsed_time_1_1_precision___t.html">Cpl::System::ElapsedTime::Precision_T</a></td>          <td class="paramname"><span class="paramname"><em>timeStamp</em>, </span></td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool</td>          <td class="paramname"><span class="paramname"><em>encodeDay</em><span class="paramdefsep"> = </span><span class="paramdefval">true</span>, </span></td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool</td>          <td class="paramname"><span class="paramname"><em>appendToString</em><span class="paramdefsep"> = </span><span class="paramdefval">false</span></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>This method converts the <a class="el" href="struct_cpl_1_1_system_1_1_elapsed_time_1_1_precision___t.html" title="Data type for time in seconds with a &#39;fractional&#39; millisecond precision.">Cpl::System::ElapsedTime::Precision_T</a> value of time into a string with the following format: "DD HH:MM:SS.SSS". </p>
<p>The converted result is returned via 'buffer'. If the results where truncated by the no enough memory in 'buffer' then false is returned; else true is returned. </p>

</div>
</div>
<a id="ab519c3ecf8ad77149f44dc41ef73f843" name="ab519c3ecf8ad77149f44dc41ef73f843"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab519c3ecf8ad77149f44dc41ef73f843">&#9670;&#160;</a></span>formatSecTimeStamp()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool Cpl::Text::formatSecTimeStamp </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="class_cpl_1_1_text_1_1_string.html">Cpl::Text::String</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>buffer</em>, </span></td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned long long</td>          <td class="paramname"><span class="paramname"><em>timeStampInSecs</em>, </span></td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool</td>          <td class="paramname"><span class="paramname"><em>encodeDay</em><span class="paramdefsep"> = </span><span class="paramdefval">true</span>, </span></td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool</td>          <td class="paramname"><span class="paramname"><em>appendToString</em><span class="paramdefsep"> = </span><span class="paramdefval">false</span></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>This method converts the binary second count of 'timeStampInSecs' to a string with the following format: "DD HH:MM:SS". </p>
<p>The converted result is returned via 'buffer'. If the results where truncated by the no enough memory in 'buffer' then false is returned; else true is returned. </p>

</div>
</div>
<a id="a3f46f4bb0cba3cd95b91d1c1f639eabe" name="a3f46f4bb0cba3cd95b91d1c1f639eabe"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3f46f4bb0cba3cd95b91d1c1f639eabe">&#9670;&#160;</a></span>isCharInString()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool Cpl::Text::isCharInString </td>
          <td>(</td>
          <td class="paramtype">const char *</td>          <td class="paramname"><span class="paramname"><em>charsSet</em>, </span></td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char</td>          <td class="paramname"><span class="paramname"><em>c</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>This method returns true if the character 'c' is one of character(s) contained in 'charsSet'; else false is returned. </p>

</div>
</div>
<a id="aa3c0120748c5f361021e6032eea64eeb" name="aa3c0120748c5f361021e6032eea64eeb"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa3c0120748c5f361021e6032eea64eeb">&#9670;&#160;</a></span>longToStr()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">const char * Cpl::Text::longToStr </td>
          <td>(</td>
          <td class="paramtype">long</td>          <td class="paramname"><span class="paramname"><em>num</em>, </span></td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">char *</td>          <td class="paramname"><span class="paramname"><em>dstString</em>, </span></td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t</td>          <td class="paramname"><span class="paramname"><em>maxChars</em>, </span></td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned</td>          <td class="paramname"><span class="paramname"><em>base</em><span class="paramdefsep"> = </span><span class="paramdefval">10</span>, </span></td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">char</td>          <td class="paramname"><span class="paramname"><em>padChar</em><span class="paramdefsep"> = </span><span class="paramdefval">'&#160;'</span></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>This method converts a long to a string. </p>
<p>If the number of converted digits exceeds the size of 'dstString', then the MOST significant digit(s) are discarded. When 'num' is negative there will always be a leading minus sign ('-') even if it means discarding a MOST significant digit. There is no feedback if/when digits are discarded.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">num</td><td>number to convert </td></tr>
    <tr><td class="paramname">dstString</td><td>buffer to hold the output </td></tr>
    <tr><td class="paramname">maxChars</td><td>size, in bytes, of 'dstString'. Note: This includes the space for the null terminator </td></tr>
    <tr><td class="paramname">base</td><td>Number base for conversion </td></tr>
    <tr><td class="paramname">padChar</td><td>The character to use to pad any unused leading characters in 'dstString'</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>a pointer to the beginning of the converted number when successful; else 0 is returned on error (e.g. illegal 'base' value). The returned pointer is essentially a left justified string of the converted value. For a right justified result, use the original pointer passed as 'dstString'. </dd></dl>

</div>
</div>
<a id="a365931bdae91b7355a26372e042889f4" name="a365931bdae91b7355a26372e042889f4"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a365931bdae91b7355a26372e042889f4">&#9670;&#160;</a></span>parsePrecisionTimeStamp()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool Cpl::Text::parsePrecisionTimeStamp </td>
          <td>(</td>
          <td class="paramtype">const char *</td>          <td class="paramname"><span class="paramname"><em>timeStampToParse</em>, </span></td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="struct_cpl_1_1_system_1_1_elapsed_time_1_1_precision___t.html">Cpl::System::ElapsedTime::Precision_T</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>convertedValue</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>This method parses a 'timestamp' with the following format: [DD ]HH:MM:SS[.sss] The method returns true if the parse was successful. </p>

</div>
</div>
<a id="aae9a2f33932dfaa319c5eb23b36fe8de" name="aae9a2f33932dfaa319c5eb23b36fe8de"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aae9a2f33932dfaa319c5eb23b36fe8de">&#9670;&#160;</a></span>removeTrailingChars()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void Cpl::Text::removeTrailingChars </td>
          <td>(</td>
          <td class="paramtype">char *</td>          <td class="paramname"><span class="paramname"><em>s</em>, </span></td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *</td>          <td class="paramname"><span class="paramname"><em>charsSet</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>This method is the same as removeTrailingSpaces(), except the specified characters set is used for "whitespace" any trailing white space. </p>
<p>NOTE: If 's' OR 'charsSet' is null, then nothing is done. </p>

</div>
</div>
<a id="af1cb01066ac4701cb10670ee4325e44b" name="af1cb01066ac4701cb10670ee4325e44b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af1cb01066ac4701cb10670ee4325e44b">&#9670;&#160;</a></span>removeTrailingSpace()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void Cpl::Text::removeTrailingSpace </td>
          <td>(</td>
          <td class="paramtype">char *</td>          <td class="paramname"><span class="paramname"><em>s</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>This method TRUNCATES the specified null-terminated string by eliminating any trailing white space. </p>
<p>NOTE: If 's' is null, then nothing is done. </p>

</div>
</div>
<a id="a062afbbf06902a24f6b7ccb6e29f673f" name="a062afbbf06902a24f6b7ccb6e29f673f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a062afbbf06902a24f6b7ccb6e29f673f">&#9670;&#160;</a></span>sizetToStr()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">const char * Cpl::Text::sizetToStr </td>
          <td>(</td>
          <td class="paramtype">size_t</td>          <td class="paramname"><span class="paramname"><em>num</em>, </span></td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">char *</td>          <td class="paramname"><span class="paramname"><em>dstString</em>, </span></td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t</td>          <td class="paramname"><span class="paramname"><em>maxChars</em>, </span></td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned</td>          <td class="paramname"><span class="paramname"><em>base</em><span class="paramdefsep"> = </span><span class="paramdefval">10</span>, </span></td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">char</td>          <td class="paramname"><span class="paramname"><em>padChar</em><span class="paramdefsep"> = </span><span class="paramdefval">'&#160;'</span></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>This method is same as <a class="el" href="#aa3c0120748c5f361021e6032eea64eeb" title="This method converts a long to a string.">longToStr()</a>, except it converts a size_t value. </p>

</div>
</div>
<a id="a99cac4baaf9aaa9f235b8d290ff002dc" name="a99cac4baaf9aaa9f235b8d290ff002dc"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a99cac4baaf9aaa9f235b8d290ff002dc">&#9670;&#160;</a></span>stripChars()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">const char * Cpl::Text::stripChars </td>
          <td>(</td>
          <td class="paramtype">const char *</td>          <td class="paramname"><span class="paramname"><em>s</em>, </span></td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *</td>          <td class="paramname"><span class="paramname"><em>charsSet</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>This method is the same as <a class="el" href="#a6c8b46bf0a7d779aba99690eb0edde40" title="This method returns a pointer to the FIRST non-whitespace character in the the specified null-termina...">stripSpace()</a>, except the specified character set is used to terminate the search instead of the standard isspace() characters. </p>
<p>NOTES: </p><pre class="fragment">o If 's' is null, then null is returned
o If 'charsSet' is null, then 's' is returned and nothing is done.
</pre> 
</div>
</div>
<a id="ae54c3fb5390a704e286863ab25c2dff6" name="ae54c3fb5390a704e286863ab25c2dff6"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae54c3fb5390a704e286863ab25c2dff6">&#9670;&#160;</a></span>stripNotChars()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">const char * Cpl::Text::stripNotChars </td>
          <td>(</td>
          <td class="paramtype">const char *</td>          <td class="paramname"><span class="paramname"><em>s</em>, </span></td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *</td>          <td class="paramname"><span class="paramname"><em>charsSet</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>This method is the same as <a class="el" href="#ab98b55d59f1d0e43d4885d9acc3beb37" title="This method returns a pointer to the FIRST whitespace character in the the specified null-terminated ...">stripNotSpace()</a>, except the specified character set is used to terminate the search instead of the standard isspace() characters. </p>
<p>NOTES: </p><pre class="fragment">o If 's' is null, then null is returned
o If 'charsSet' is null, then 's' is returned and nothing is done.
</pre> 
</div>
</div>
<a id="ab98b55d59f1d0e43d4885d9acc3beb37" name="ab98b55d59f1d0e43d4885d9acc3beb37"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab98b55d59f1d0e43d4885d9acc3beb37">&#9670;&#160;</a></span>stripNotSpace()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">const char * Cpl::Text::stripNotSpace </td>
          <td>(</td>
          <td class="paramtype">const char *</td>          <td class="paramname"><span class="paramname"><em>s</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>This method returns a pointer to the FIRST whitespace character in the the specified null-terminated string. </p>
<p>NOTES: </p><pre class="fragment">o This method does NOT modify the original string in any way!
o If 's' is null, then null is returned.
</pre><p>This method is useful in finding the 'next' token in a string, for example: </p><div class="fragment"><div class="line"><span class="comment">// Returns a pointer to the first token in &#39;input&#39;</span></div>
<div class="line"><span class="keyword">const</span> <span class="keywordtype">char</span>* token = <a class="code hl_function" href="#a6c8b46bf0a7d779aba99690eb0edde40">stripSpace</a>(input)</div>
<div class="line"> </div>
<div class="line"><span class="comment">// Returns a pointer to the second token in &#39;input&#39;</span></div>
<div class="line">token = <a class="code hl_function" href="#a6c8b46bf0a7d779aba99690eb0edde40">stripSpace</a>(<a class="code hl_function" href="#ab98b55d59f1d0e43d4885d9acc3beb37">stripNotSpace</a>(token))</div>
<div class="ttc" id="anamespace_cpl_1_1_text_html_a6c8b46bf0a7d779aba99690eb0edde40"><div class="ttname"><a href="#a6c8b46bf0a7d779aba99690eb0edde40">Cpl::Text::stripSpace</a></div><div class="ttdeci">const char * stripSpace(const char *s)</div><div class="ttdoc">This method returns a pointer to the FIRST non-whitespace character in the the specified null-termina...</div></div>
<div class="ttc" id="anamespace_cpl_1_1_text_html_ab98b55d59f1d0e43d4885d9acc3beb37"><div class="ttname"><a href="#ab98b55d59f1d0e43d4885d9acc3beb37">Cpl::Text::stripNotSpace</a></div><div class="ttdeci">const char * stripNotSpace(const char *s)</div><div class="ttdoc">This method returns a pointer to the FIRST whitespace character in the the specified null-terminated ...</div></div>
</div><!-- fragment --> 
</div>
</div>
<a id="a6c8b46bf0a7d779aba99690eb0edde40" name="a6c8b46bf0a7d779aba99690eb0edde40"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6c8b46bf0a7d779aba99690eb0edde40">&#9670;&#160;</a></span>stripSpace()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">const char * Cpl::Text::stripSpace </td>
          <td>(</td>
          <td class="paramtype">const char *</td>          <td class="paramname"><span class="paramname"><em>s</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>This method returns a pointer to the FIRST non-whitespace character in the the specified null-terminated string. </p>
<p>NOTES: </p><pre class="fragment">o This method does NOT modify the original string in any way!
o If 's' is null, then null is returned.
</pre> 
</div>
</div>
<a id="a462b96d5d7456b0e284e94de1736fb3b" name="a462b96d5d7456b0e284e94de1736fb3b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a462b96d5d7456b0e284e94de1736fb3b">&#9670;&#160;</a></span>stripTrailingChars()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">const char * Cpl::Text::stripTrailingChars </td>
          <td>(</td>
          <td class="paramtype">const char *</td>          <td class="paramname"><span class="paramname"><em>s</em>, </span></td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *</td>          <td class="paramname"><span class="paramname"><em>charsSet</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>This method is the same as stripTrailingSpaces(), except the specified character set is used to identify the last "non-whitespace" character. </p>
<p>NOTES: </p><pre class="fragment">o If 's' is null, then null is returned
o If 'charsSet' is null, then 's' is returned and nothing is done.
o If the entire string is made up of 'charsSet', a pointer to the start
  of the string is returned (i.e. 's' returned)
</pre> 
</div>
</div>
<a id="addf14c7fbc3870724da378fc9da00cdf" name="addf14c7fbc3870724da378fc9da00cdf"></a>
<h2 class="memtitle"><span class="permalink"><a href="#addf14c7fbc3870724da378fc9da00cdf">&#9670;&#160;</a></span>stripTrailingSpace()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">const char * Cpl::Text::stripTrailingSpace </td>
          <td>(</td>
          <td class="paramtype">const char *</td>          <td class="paramname"><span class="paramname"><em>s</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>This method returns a pointer to the LAST non-whitespace character in the the specified null-terminated string. </p>
<p>NOTES: </p><pre class="fragment">o This method does NOT modify the original string in any way!
o If 's' is null, then null is returned.
o If the entire string is whitespace, a pointer to the start of
  the string is returned (i.e. 's' returned)
</pre> 
</div>
</div>
<a id="a744cb16fbbf617dc1cdbb8fbd77feff8" name="a744cb16fbbf617dc1cdbb8fbd77feff8"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a744cb16fbbf617dc1cdbb8fbd77feff8">&#9670;&#160;</a></span>ulongToStr()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">const char * Cpl::Text::ulongToStr </td>
          <td>(</td>
          <td class="paramtype">unsigned long</td>          <td class="paramname"><span class="paramname"><em>num</em>, </span></td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">char *</td>          <td class="paramname"><span class="paramname"><em>dstString</em>, </span></td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t</td>          <td class="paramname"><span class="paramname"><em>maxChars</em>, </span></td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned</td>          <td class="paramname"><span class="paramname"><em>base</em><span class="paramdefsep"> = </span><span class="paramdefval">10</span>, </span></td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">char</td>          <td class="paramname"><span class="paramname"><em>padChar</em><span class="paramdefsep"> = </span><span class="paramdefval">'&#160;'</span></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>This method is same as <a class="el" href="#aa3c0120748c5f361021e6032eea64eeb" title="This method converts a long to a string.">longToStr()</a>, except it converts a unsigned long value. </p>

</div>
</div>
<a id="a4c50715706396ff46bd0b67c442d189a" name="a4c50715706396ff46bd0b67c442d189a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a4c50715706396ff46bd0b67c442d189a">&#9670;&#160;</a></span>unhex()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool Cpl::Text::unhex </td>
          <td>(</td>
          <td class="paramtype">const char *</td>          <td class="paramname"><span class="paramname"><em>inString</em>, </span></td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t</td>          <td class="paramname"><span class="paramname"><em>numCharToScan</em>, </span></td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint8_t *</td>          <td class="paramname"><span class="paramname"><em>outData</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>This method converts up to 'numCharToScan' characters from the ASCII HEX text string. </p>
<p>The converted binary data is stored in 'outData'.</p>
<p>The application is responsible for ENSURING that the 'outData' is large enough to hold the converted output! </p>

</div>
</div>
<a id="ae63c1c1fb47d22a4cf298bb8b70c6a23" name="ae63c1c1fb47d22a4cf298bb8b70c6a23"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae63c1c1fb47d22a4cf298bb8b70c6a23">&#9670;&#160;</a></span>unhexChar()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">uint8_t Cpl::Text::unhexChar </td>
          <td>(</td>
          <td class="paramtype">char</td>          <td class="paramname"><span class="paramname"><em>c</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Returns the binary value for the 'ASCII HEX' character 'c'. </p>
<p>Returns -1 if there is an error (e.g. 'c' is not valid 'hex' character) </p>

</div>
</div>
</div><!-- contents -->
<!-- start footer part -->
<hr class="footer"/><address class="footer"><small>
Generated on Thu Jul 25 2024 23:55:51 for Patterns in the Machine by&#160;<a href="https://www.doxygen.org/index.html"><img class="footer" src="doxygen.svg" width="104" height="31" alt="doxygen"/></a> 1.10.0
</small></address>
</body>
</html>
