<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "https://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.8.18"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>PIM: Driver::Uart::Stream::Transmitter Class Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td id="projectlogo"><img alt="Logo" src="logo2.gif"/></td>
  <td id="projectalign" style="padding-left: 0.5em;">
   <div id="projectname">PIM
   </div>
   <div id="projectbrief">Patterns in the Machine: Thermostat Example</div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.8.18 -->
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
$(function() {
  initMenu('',false,false,'search.php','Search');
});
/* @license-end */</script>
<div id="main-nav"></div>
<div id="nav-path" class="navpath">
  <ul>
<li class="navelem"><a class="el" href="namespace_driver.html">Driver</a></li><li class="navelem"><a class="el" href="namespace_driver_1_1_uart.html">Uart</a></li><li class="navelem"><a class="el" href="namespace_driver_1_1_uart_1_1_stream.html">Stream</a></li><li class="navelem"><a class="el" href="class_driver_1_1_uart_1_1_stream_1_1_transmitter.html">Transmitter</a></li>  </ul>
</div>
</div><!-- top -->
<div class="header">
  <div class="summary">
<a href="class_driver_1_1_uart_1_1_stream_1_1_transmitter-members.html">List of all members</a> &#124;
<a href="#pub-methods">Public Member Functions</a> &#124;
<a href="#pro-attribs">Protected Attributes</a>  </div>
  <div class="headertitle">
<div class="title">Driver::Uart::Stream::Transmitter Class Reference</div>  </div>
</div><!--header-->
<div class="contents">

<p>This concrete class implements a blocking Transmit <a class="el" href="namespace_driver_1_1_uart_1_1_stream.html">Stream</a> UART driver.  
 <a href="class_driver_1_1_uart_1_1_stream_1_1_transmitter.html#details">More...</a></p>
<a name="details" id="details"></a><h2 class="groupheader">Detailed Description</h2>
<div class="textblock"><p>This concrete class implements a blocking Transmit <a class="el" href="namespace_driver_1_1_uart_1_1_stream.html">Stream</a> UART driver. </p>
<p>What does 'blocking Transmit <a class="el" href="namespace_driver_1_1_uart_1_1_stream.html">Stream</a>' mean? 'Blocking' means that the calling thread will block when the transmit buffer is full (and will be unblocked once there is free space in the transmit buffer). '<a class="el" href="namespace_driver_1_1_uart_1_1_stream.html">Stream</a>' means that data is transmitted as a continual stream of bytes, i.e. the data is NOT broken down into frames, packets, etc. (think C stdout stream).</p>
<p>This driver ASSUMES that at most there is only ONE client attempt to use the driver at any given time. It is okay to call the <a class="el" href="class_driver_1_1_uart_1_1_stream_1_1_transmitter.html#acb67aa6f0cb4658bdee1d1f2eb71a98b" title="This method starts/enables the driver.">start()</a>, <a class="el" href="class_driver_1_1_uart_1_1_stream_1_1_transmitter.html#a5faa95cdd769381765f8fe90c002fc31" title="This method will stop/disable the driver.">stop()</a>, <a class="el" href="class_driver_1_1_uart_1_1_stream_1_1_transmitter.html#a298ac39d4ad552ac5b6d5590431bf54a" title="Transmits the specified number of bytes.">write()</a> from different threads - but the calls CANNOT be concurrent. It is the application's responsibility to provide additional thread-safety/concurrence protection.</p>
<p>NOTE: Not all UART behave the same with respect to transmitting the 'first' byte (in a stream/buffer of bytes). One method (which is the default for <a class="el" href="namespace_cpl.html">Cpl</a>) is that a 'TX-done' interrupt is generated any time the TX data register is empty and the TX-done interrupt is enabled, i.e. the first byte in the stream/buffer is handle the same as all of the other bytes. The second method is that the application/driver is required to explicitly write the first byte to the TX Data register, i.e. no interrupt for the initial byte. </p>
</div>
<p><code>#include &lt;<a class="el" href="_transmitter_8h_source.html">Transmitter.h</a>&gt;</code></p>
<div id="dynsection-0" onclick="return toggleVisibility(this)" class="dynheader closed" style="cursor:pointer;">
  <img id="dynsection-0-trigger" src="closed.png" alt="+"/> Collaboration diagram for Driver::Uart::Stream::Transmitter:</div>
<div id="dynsection-0-summary" class="dynsummary" style="display:block;">
</div>
<div id="dynsection-0-content" class="dyncontent" style="display:none;">
<div class="center"><iframe scrolling="no" frameborder="0" src="class_driver_1_1_uart_1_1_stream_1_1_transmitter__coll__graph.svg" width="360" height="336"><p><b>This browser is not able to show SVG: try Firefox, Chrome, Safari, or Opera instead.</b></p></iframe>
</div>
<center><span class="legend">[<a href="graph_legend.html">legend</a>]</span></center></div>
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pub-methods"></a>
Public Member Functions</h2></td></tr>
<tr class="memitem:a66ea4151ad4a76ab46848673c4fa6722"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_driver_1_1_uart_1_1_stream_1_1_transmitter.html#a66ea4151ad4a76ab46848673c4fa6722">Transmitter</a> (<a class="el" href="_driver_2_uart_2_hal_8h.html#a5f535f0949931d4b9b624b0e0fe300cf">Driver_Uart_Hal_T</a> uartHdl, unsigned bufSize, uint8_t bufMem[], bool manualFirstTx=false) noexcept</td></tr>
<tr class="memdesc:a66ea4151ad4a76ab46848673c4fa6722"><td class="mdescLeft">&#160;</td><td class="mdescRight">Constructor.  <a href="class_driver_1_1_uart_1_1_stream_1_1_transmitter.html#a66ea4151ad4a76ab46848673c4fa6722">More...</a><br /></td></tr>
<tr class="separator:a66ea4151ad4a76ab46848673c4fa6722"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:acb67aa6f0cb4658bdee1d1f2eb71a98b"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_driver_1_1_uart_1_1_stream_1_1_transmitter.html#acb67aa6f0cb4658bdee1d1f2eb71a98b">start</a> (void) noexcept</td></tr>
<tr class="memdesc:acb67aa6f0cb4658bdee1d1f2eb71a98b"><td class="mdescLeft">&#160;</td><td class="mdescRight">This method starts/enables the driver.  <a href="class_driver_1_1_uart_1_1_stream_1_1_transmitter.html#acb67aa6f0cb4658bdee1d1f2eb71a98b">More...</a><br /></td></tr>
<tr class="separator:acb67aa6f0cb4658bdee1d1f2eb71a98b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5faa95cdd769381765f8fe90c002fc31"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_driver_1_1_uart_1_1_stream_1_1_transmitter.html#a5faa95cdd769381765f8fe90c002fc31">stop</a> (void) noexcept</td></tr>
<tr class="memdesc:a5faa95cdd769381765f8fe90c002fc31"><td class="mdescLeft">&#160;</td><td class="mdescRight">This method will stop/disable the driver.  <a href="class_driver_1_1_uart_1_1_stream_1_1_transmitter.html#a5faa95cdd769381765f8fe90c002fc31">More...</a><br /></td></tr>
<tr class="separator:a5faa95cdd769381765f8fe90c002fc31"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a298ac39d4ad552ac5b6d5590431bf54a"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_driver_1_1_uart_1_1_stream_1_1_transmitter.html#a298ac39d4ad552ac5b6d5590431bf54a">write</a> (const void *data, size_t numBytesToTx) noexcept</td></tr>
<tr class="memdesc:a298ac39d4ad552ac5b6d5590431bf54a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Transmits the specified number of bytes.  <a href="class_driver_1_1_uart_1_1_stream_1_1_transmitter.html#a298ac39d4ad552ac5b6d5590431bf54a">More...</a><br /></td></tr>
<tr class="separator:a298ac39d4ad552ac5b6d5590431bf54a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4eae934441b29a7371a41ae8b2a83d80"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_driver_1_1_uart_1_1_stream_1_1_transmitter.html#a4eae934441b29a7371a41ae8b2a83d80">su_txDoneIsr_</a> (void) noexcept</td></tr>
<tr class="memdesc:a4eae934441b29a7371a41ae8b2a83d80"><td class="mdescLeft">&#160;</td><td class="mdescRight">This is a quasi-private method that the application should NOT call.  <a href="class_driver_1_1_uart_1_1_stream_1_1_transmitter.html#a4eae934441b29a7371a41ae8b2a83d80">More...</a><br /></td></tr>
<tr class="separator:a4eae934441b29a7371a41ae8b2a83d80"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pro-attribs"></a>
Protected Attributes</h2></td></tr>
<tr class="memitem:a0779dfc65693c9bf95f15bf8dba21633"><td class="memItemLeft" align="right" valign="top"><a class="el" href="_driver_2_uart_2_hal_8h.html#a5f535f0949931d4b9b624b0e0fe300cf">Driver_Uart_Hal_T</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_driver_1_1_uart_1_1_stream_1_1_transmitter.html#a0779dfc65693c9bf95f15bf8dba21633">m_uartHdl</a></td></tr>
<tr class="memdesc:a0779dfc65693c9bf95f15bf8dba21633"><td class="mdescLeft">&#160;</td><td class="mdescRight">Handle to my low level hardware.  <a href="class_driver_1_1_uart_1_1_stream_1_1_transmitter.html#a0779dfc65693c9bf95f15bf8dba21633">More...</a><br /></td></tr>
<tr class="separator:a0779dfc65693c9bf95f15bf8dba21633"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7fc70f07e8480d5c40099420aad16bbc"><td class="memItemLeft" align="right" valign="top"><a class="el" href="class_cpl_1_1_system_1_1_thread.html">Cpl::System::Thread</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_driver_1_1_uart_1_1_stream_1_1_transmitter.html#a7fc70f07e8480d5c40099420aad16bbc">m_waiterPtr</a></td></tr>
<tr class="memdesc:a7fc70f07e8480d5c40099420aad16bbc"><td class="mdescLeft">&#160;</td><td class="mdescRight">Handle of the blocked client thread (if there is one)  <a href="class_driver_1_1_uart_1_1_stream_1_1_transmitter.html#a7fc70f07e8480d5c40099420aad16bbc">More...</a><br /></td></tr>
<tr class="separator:a7fc70f07e8480d5c40099420aad16bbc"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab49048fe80adbec59b667a55b285cc00"><td class="memItemLeft" align="right" valign="top"><a class="el" href="class_cpl_1_1_container_1_1_ring_buffer.html">Cpl::Container::RingBuffer</a>&lt; uint8_t &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_driver_1_1_uart_1_1_stream_1_1_transmitter.html#ab49048fe80adbec59b667a55b285cc00">m_buffer</a></td></tr>
<tr class="memdesc:ab49048fe80adbec59b667a55b285cc00"><td class="mdescLeft">&#160;</td><td class="mdescRight">Transmit buffer.  <a href="class_driver_1_1_uart_1_1_stream_1_1_transmitter.html#ab49048fe80adbec59b667a55b285cc00">More...</a><br /></td></tr>
<tr class="separator:ab49048fe80adbec59b667a55b285cc00"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a13c0e1e3ce3265cf940d30bc5a9b6b88"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_driver_1_1_uart_1_1_stream_1_1_transmitter.html#a13c0e1e3ce3265cf940d30bc5a9b6b88">m_started</a></td></tr>
<tr class="memdesc:a13c0e1e3ce3265cf940d30bc5a9b6b88"><td class="mdescLeft">&#160;</td><td class="mdescRight">Started state of the driver.  <a href="class_driver_1_1_uart_1_1_stream_1_1_transmitter.html#a13c0e1e3ce3265cf940d30bc5a9b6b88">More...</a><br /></td></tr>
<tr class="separator:a13c0e1e3ce3265cf940d30bc5a9b6b88"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad377db183f0f13ae66d39105816c72d1"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_driver_1_1_uart_1_1_stream_1_1_transmitter.html#ad377db183f0f13ae66d39105816c72d1">m_manualFirstTx</a></td></tr>
<tr class="memdesc:ad377db183f0f13ae66d39105816c72d1"><td class="mdescLeft">&#160;</td><td class="mdescRight">First TX behavior option.  <a href="class_driver_1_1_uart_1_1_stream_1_1_transmitter.html#ad377db183f0f13ae66d39105816c72d1">More...</a><br /></td></tr>
<tr class="separator:ad377db183f0f13ae66d39105816c72d1"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<h2 class="groupheader">Constructor &amp; Destructor Documentation</h2>
<a id="a66ea4151ad4a76ab46848673c4fa6722"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a66ea4151ad4a76ab46848673c4fa6722">&#9670;&nbsp;</a></span>Transmitter()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">Driver::Uart::Stream::Transmitter::Transmitter </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="_driver_2_uart_2_hal_8h.html#a5f535f0949931d4b9b624b0e0fe300cf">Driver_Uart_Hal_T</a>&#160;</td>
          <td class="paramname"><em>uartHdl</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned&#160;</td>
          <td class="paramname"><em>bufSize</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint8_t&#160;</td>
          <td class="paramname"><em>bufMem</em>[], </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>manualFirstTx</em> = <code>false</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Constructor. </p>
<p>Note: The driver does not begin operating until <a class="el" href="class_driver_1_1_uart_1_1_stream_1_1_transmitter.html#acb67aa6f0cb4658bdee1d1f2eb71a98b" title="This method starts/enables the driver.">start()</a> is called.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">uartHdl</td><td>The HAL layer UART Handle. The application is required to initialize the low level UART before starting this driver. </td></tr>
    <tr><td class="paramname">bufSize</td><td>The number of bytes in the supplied transmit buffer. </td></tr>
    <tr><td class="paramname">bufMem</td><td>Array of bytes for the transmit/outbound buffer. </td></tr>
    <tr><td class="paramname">manualFirstTx</td><td>When this flag is set to false the driver assumes that the initial byte to be transmitted is interrupt driven. When set to true, the initial transmitted byte is 'manually' loaded. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<h2 class="groupheader">Member Function Documentation</h2>
<a id="acb67aa6f0cb4658bdee1d1f2eb71a98b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#acb67aa6f0cb4658bdee1d1f2eb71a98b">&#9670;&nbsp;</a></span>start()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void Driver::Uart::Stream::Transmitter::start </td>
          <td>(</td>
          <td class="paramtype">void&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>This method starts/enables the driver. </p>
<p>Note: The application is RESPONSIBLE for performing the low level initialization (Baud Rate, framing, etc.) of the UART BEFORE this method is called. For the application to change the Baud rate, framing, etc - it must first stop the driver and then restart it. </p>

</div>
</div>
<a id="a5faa95cdd769381765f8fe90c002fc31"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5faa95cdd769381765f8fe90c002fc31">&#9670;&nbsp;</a></span>stop()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void Driver::Uart::Stream::Transmitter::stop </td>
          <td>(</td>
          <td class="paramtype">void&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>This method will stop/disable the driver. </p>
<p>The driver can be restarted by call <a class="el" href="class_driver_1_1_uart_1_1_stream_1_1_transmitter.html#acb67aa6f0cb4658bdee1d1f2eb71a98b" title="This method starts/enables the driver.">start()</a> again. The state of the contents of the outbound buffer and the byte(s) 'in transmit' when the driver is stop is undetermined. </p>

</div>
</div>
<a id="a4eae934441b29a7371a41ae8b2a83d80"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a4eae934441b29a7371a41ae8b2a83d80">&#9670;&nbsp;</a></span>su_txDoneIsr_()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">int Driver::Uart::Stream::Transmitter::su_txDoneIsr_ </td>
          <td>(</td>
          <td class="paramtype">void&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>This is a quasi-private method that the application should NOT call. </p>
<p>The method SHOULD only be called by the interrupt service routine (ISR) for the 'TX-Done' interrupt for the UART identified by the 'uartHdl' supplied in the constructor. This requires that a reference (at a minimum) to the driver instance be a global variable.</p>
<p>The method returns the result of signaling waiter (i.e. return code from su_signal()), or zero if no waiter was signaled. </p>

</div>
</div>
<a id="a298ac39d4ad552ac5b6d5590431bf54a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a298ac39d4ad552ac5b6d5590431bf54a">&#9670;&nbsp;</a></span>write()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool Driver::Uart::Stream::Transmitter::write </td>
          <td>(</td>
          <td class="paramtype">const void *&#160;</td>
          <td class="paramname"><em>data</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>numBytesToTx</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Transmits the specified number of bytes. </p>
<p>The method does not return until all bytes have been transferred to the outbound buffer. The application CANNOT assume that the byte(s) have been physically transmitted on the 'wire' when this method returns. The method returns true if successful; else false is returned When an error is encounter there is no guaranty/information-available with respect to how many (if any) bytes where transmitted. </p>

</div>
</div>
<h2 class="groupheader">Member Data Documentation</h2>
<a id="ab49048fe80adbec59b667a55b285cc00"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab49048fe80adbec59b667a55b285cc00">&#9670;&nbsp;</a></span>m_buffer</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="class_cpl_1_1_container_1_1_ring_buffer.html">Cpl::Container::RingBuffer</a>&lt;uint8_t&gt; Driver::Uart::Stream::Transmitter::m_buffer</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Transmit buffer. </p>

</div>
</div>
<a id="ad377db183f0f13ae66d39105816c72d1"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad377db183f0f13ae66d39105816c72d1">&#9670;&nbsp;</a></span>m_manualFirstTx</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool Driver::Uart::Stream::Transmitter::m_manualFirstTx</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>First TX behavior option. </p>

</div>
</div>
<a id="a13c0e1e3ce3265cf940d30bc5a9b6b88"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a13c0e1e3ce3265cf940d30bc5a9b6b88">&#9670;&nbsp;</a></span>m_started</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool Driver::Uart::Stream::Transmitter::m_started</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Started state of the driver. </p>

</div>
</div>
<a id="a0779dfc65693c9bf95f15bf8dba21633"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0779dfc65693c9bf95f15bf8dba21633">&#9670;&nbsp;</a></span>m_uartHdl</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="_driver_2_uart_2_hal_8h.html#a5f535f0949931d4b9b624b0e0fe300cf">Driver_Uart_Hal_T</a> Driver::Uart::Stream::Transmitter::m_uartHdl</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Handle to my low level hardware. </p>

</div>
</div>
<a id="a7fc70f07e8480d5c40099420aad16bbc"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7fc70f07e8480d5c40099420aad16bbc">&#9670;&nbsp;</a></span>m_waiterPtr</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="class_cpl_1_1_system_1_1_thread.html">Cpl::System::Thread</a>* Driver::Uart::Stream::Transmitter::m_waiterPtr</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Handle of the blocked client thread (if there is one) </p>

</div>
</div>
<hr/>The documentation for this class was generated from the following file:<ul>
<li>Driver/Uart/Stream/<a class="el" href="_transmitter_8h_source.html">Transmitter.h</a></li>
</ul>
</div><!-- contents -->
<!-- start footer part -->
<hr class="footer"/><address class="footer"><small>
Generated on Thu Dec 10 2020 16:32:58 for PIM by &#160;<a href="http://www.doxygen.org/index.html">
<img class="footer" src="doxygen.png" alt="doxygen"/>
</a> 1.8.18
</small></address>
</body>
</html>
