#!/usr/bin/python3
#=============================================================================
# Helper script (that does most of work) for generating FSM source code from
# Cadifra FSM diagrams
#
# This script runs the 'sinelaboreRT' Finite State Machine Code Generator
# utility.  The SinelaboreRT tool is proprietary tool, but the output of
# the code generator is NOT.  This script is also specific to parsing
# FSM diagramS generated by the Cadifra drawing tool (yet another 
# proprietary tool).  Yes - using non open source tools is straying from
# the pure faith - but both tools are very good and affordable - and the
# generated source code and diagram content is still 'free'.
#
# http://www.sinelabore.com/
# http://www.cadifra.com/
#
#=============================================================================

#
import sys   
import os
import subprocess
#
from nqbplib.docopt.docopt import docopt
from nqbplib import utils

# 
usage = """ 
genfsm - Generates source code from Cadifra FSM Diagrams (.cdd files)
===============================================================================
Usage: genfsm [options] <basename> <namespaces> [<sinelabore>...]

Arguments:
  <basename>       Base name for the FSM.  The Cadifra diagram must have this
                   same file name.  All generated output files will have the 
                   <basename> as part of their file names. <basename> IS 
                   case sensitive!
      
  <namespaces>     The encapsulated namespace(s) for the generated files. The
                   Format is: 'Rte::Db::Record'
                   
  <sinelabore>     Optional arguments passed directly to the Sinelabore code
                   generator

Options:
  -d NEVENTS       When NEVENTS is greater then 0 code for an event queue is 
                   generated where NEVENTS is the size of the event queue. 
                   [Default: 0]
  -h, --help       Display command help.
        
         
NOTES:
    o The environment variable SINELABORE_PATH is required/used to specify
      the location of the Sinelabore code generator JAR files (and it 
      supporting JAR files).
    o The script assumes that Graphviz's dot.exe is in the command path.
      GraphViz is used to generated the FSM diagram for Doxygen. See 
      http://www.graphviz.org
      
"""

copyright_header = """* This file is part of the Colony.Core Project.  The Colony.Core Project is an
* open source project with a BSD type of licensing agreement.  See the license
* agreement (license.txt) in the top/ directory or on the Internet at
* http://integerfox.com/colony.core/license.txt
*
* Copyright (c) 2014-2020  John T. Taylor
*
* Redistributions of the source code must retain the above copyright notice."""

#
import subprocess
import re
import sys

#------------------------------------------------------------------------------
# Parse command line
def run( argv, copyright=None ):
    global copyright_header

    # Process command line args...
    args  = docopt(usage, version="0.0.1", options_first=True )
    sargs = ' '.join( args['<sinelabore>'] )

    # Check the environment variables 
    sinpath = os.environ.get( "SINELABORE_PATH" )
    if ( sinpath == None ):
        exit( "ERROR: The SINELABORE_PATH environment variable is not set." )
    
    # Set copyright header (if specified)
    if ( copyright != None ):
        copyright_header = copyright

    # Convert namespace arg to list
    names = args['<namespaces>'].split('::')
    
    # Filenames
    fsmdiag = args['<basename>'] + ".cdd"
    base    = args['<basename>'] + "Context_" 
    evque   = args['<basename>'] + "EventQueue_" 
    fsm     = args['<basename>'] 
    cfg     = 'codegen.cfg'
      
    # Generated File names
    oldfsm    = fsm + '.h'
    oldfsmcpp = fsm + '.cpp'
    oldevt    = fsm + '_ext.h'
    oldtrace  = fsm + '_trace.h'
    oldtrace2 = fsm + '_trace.java'
    newfsm    = fsm + '_.h'
    newfsmcpp = fsm + '_.cpp'
    newevt    = fsm + '_ext_.h'
    newtrace  = fsm + '_trace_.h'
    
    # Delete 'optional' old/previous files 
    utils.delete_file( evque + ".h" )
    utils.delete_file( evque + ".cpp" )
    
    # Create the config file for Sinelabore
    geneatedCodegenConfig( cfg, base, names )
        
    # Build Sinelabore command
    cmd = 'java -jar -Djava.ext.dirs={} {}/codegen.jar {} -p CADIFRA -doxygen -o {} -l cppx -Trace {}'.format( sinpath, sinpath, sargs, fsm, fsmdiag )
    cmd = utils.standardize_dir_sep( cmd )
  
    # Invoke Sinelabore command
    print(cmd)
    p = subprocess.Popen( cmd, shell=True )
    r = p.communicate()
    if ( p.returncode != 0 ):
        exit("ERROR: Sinelabore encounterd an error or failed to run." )
    
    # Clean-up config file (don't want it being checked into version control)
    os.remove( cfg )
    
    # Mangle the event names so that I can have many FSMs in the same namespace with the same event names
    eventList = get_events_names( oldevt )
    mangle_event_names( oldevt, eventList, fsm, ' ' )
    mangle_event_names( oldfsmcpp, eventList, fsm, '"', '0', '=' )
    mangle_event_names( oldtrace, eventList, fsm, '"' )
    cleanup_global_define( oldevt, fsm, names )

    # Generate Context/Base class
    actions, guards = getContextMethods( fsmdiag )
    generatedContextClass( base, names, getHeader(), actions, guards )
    
    # Generated event queuue class
    depth = args['-d'].strip()  
    if ( depth != '0' ):
        generateEventClass( evque, names, fsm, newfsm, depth )
        
    # Post process the generated file(s) to work better with Doxygen
    cleanup_for_doxygen( fsm + ".h", args['<namespaces>'] + "::" + fsm )
    cleanup_for_doxygen( oldtrace )
    cleanup_for_doxygen( oldevt )
      
    
    # Post process the generated file(s) 
    cleanup_trace( oldfsmcpp, names, fsm, oldfsm, oldtrace, newtrace )
    cleanup_includes( oldfsm,    names, oldfsm, newfsm, oldevt, newevt, base + '.h' )
    cleanup_includes( oldfsmcpp, names, oldfsm, newfsm, oldevt, newevt, base + '.h' )
      
    # Housekeeping for naming convention
    utils.delete_file( newfsm )
    utils.delete_file( newfsmcpp )
    utils.delete_file( newevt )
    utils.delete_file( newtrace )
    utils.delete_file( oldtrace2 )  # remove unwanted JAVA file
    os.rename( oldfsm, newfsm )
    os.rename( oldfsmcpp, newfsmcpp ) 
    os.rename( oldevt, newevt ) 
    os.rename( oldtrace, newtrace ) 



#------------------------------------------------------------------------------
def get_events_names( ext_header_file ):
    found_start = False
    events      = []
    with open( ext_header_file ) as inf:
        for line in inf:
            line = line.lstrip()

            # Capture events
            if ( found_start ):
                if ( line.find("_NO_MSG") == -1 ):
                    event = line.strip().split('=')[0]
                    event = event.strip().split(',')[0]
                    events.append( event.strip() )

                # All events found -->can exit the function
                else:
                    break;

            # Find the start of the events                    
            if ( line.startswith( "enum" ) ):
                found_start = True

    # Return found events
    return events  

#
def mangle_event_names( file, events, prefix, pre_del1, pre_del2=None, pre_del3=None ):
    tmpfile       = file + ".tmp"
    found_indexes = False    
    with open( file ) as inf:
        with open( tmpfile, "w") as outf:  
            for line in inf:

                # Replace event names
                for e in events:
                    # Brute force approach to replacing whole event names (i.e. properly handle evStop & evStopped)
                    old_ev = pre_del1 + e
                    new_ev = pre_del1 + prefix + "_" + e
                    line   = line.replace(old_ev,new_ev,1)
                    if ( pre_del2 != None ):
                        old_ev = pre_del2 + e
                        new_ev = pre_del2 + prefix + "_" + e
                        line   = line.replace(old_ev,new_ev,1)
                        if ( pre_del3 != None ):
                            old_ev = pre_del3 + e
                            new_ev = pre_del3 + prefix + "_" + e
                            line   = line.replace(old_ev,new_ev,1)
                    
                # Fix event name indexes
                if ( found_indexes ):
                    line = fix_indexes( line, prefix );
                    found_indexes = False
                elif ( line.find( "const unsigned short evt_idx[]={" ) != -1 ):
                    found_indexes = True
                         
                outf.write( line )
    
    os.remove( file )
    os.rename( tmpfile, file )


# 
def fix_indexes( line, prefix ):
    line       = line.replace('};','').strip()
    k          = len(prefix) + 1
    offsets    = line.strip().split(",")
    idx        = 0
    newoffsets = []
    
    # Strip off potential trailing ',' (e.g. happens when there are no 'true' events)
    if ( offsets[len(offsets)-1] == '' ):
        del offsets[len(offsets)-1]

    for i in offsets:
        n      = int(i)
        newidx = n + idx * k
        idx   += 1
        newoffsets.append( str(newidx) )
        
    newline  = "        " + ','.join(newoffsets) + '};\n'
    return newline
        
    
#
def cleanup_for_doxygen( headerfile, classname='<not-used>' ):
    tmpfile = headerfile + ".tmp"
    skip_state = 0
    with open( headerfile ) as inf:
        with open( tmpfile, "w") as outf:  
            for line in inf:
                if ( line.startswith( "namespace") and skip_state == 0 ):
                    outf.write( "#ifndef DOXYGEN_WILL_SKIP_THIS\n\n");
                    outf.write( line );
                    skip_state += 1
                    continue
                if ( line.startswith( "#endif") and skip_state == 1):
                    outf.write( "#endif // !DOXYGEN_WILL_SKIP_THIS\n\n");
                    outf.write( line );
                    skip_state += 1
                    continue

                if ( line.find( 'Here is the graph that shows the state machine' ) == -1 ):
                    outf.write( line )
                else:
                    outf.write( "/** \class {}\n\nHere is the graph that shows the state machine this class implements\n\n\dot\n".format( classname ) )
    
    os.remove( headerfile )
    os.rename( tmpfile, headerfile )
 
#
def cleanup_global_define( headerfile, fsm_name, namespaces ):
    tmpfile = headerfile + ".tmp"
    skip_state = 0
    with open( headerfile ) as inf:
        with open( tmpfile, "w") as outf:  
            for line in inf:

                if ( line.startswith( '#define InnermostStates ' )-1 ):
                    outf.write( line )
                else:
                    tokens = line.split()
                    outf.write( '#define {}{}_InnermostStates {};\n'.format(flatten_namespaces(namespaces), fsm_name, tokens[2]))
    
    os.remove( headerfile )
    os.rename( tmpfile, headerfile )
                     

#
def cleanup_includes( headerfile, namespaces, oldfsm, newfsm, oldevt, newevt, base ):
    tmpfile = headerfile + ".tmp"
    path    = path_namespaces( namespaces )
    
    with open( headerfile ) as inf:
        with open( tmpfile, "w") as outf:  
            for line in inf:
                if ( line.find( '#include "{}"'.format(oldfsm) ) != -1):
                    outf.write( '#include "{}{}"\n'.format(path, newfsm) )
                elif ( line.find( '#include "{}"'.format(oldevt) ) != -1) :
                    outf.write( '#include "{}{}"\n'.format(path, newevt) )
                elif ( line.find( '#include "{}"'.format(base) ) != -1) :
                    outf.write( '#include "{}{}"\n'.format(path, base) )
                else:
                    outf.write( line )
    
    os.remove( headerfile )
    os.rename( tmpfile, headerfile )
      
#      
def cleanup_trace( cppfile, namespaces, base, oldfsm, old_trace_headerfile, new_trace_headerfile ):
    # Add xx_trace_.h include to xxx_.cpp
    tmpfile  = cppfile + ".tmp"
    path     = path_namespaces( namespaces )
    newstate = 'stateVars = stateVarsCopy;'
    newcount = 0
    
    # Update the state machine .cpp file with Tracing tweaks
    prev_line = ''
    with open( cppfile ) as inf:
        with open( tmpfile, "w") as outf:  
            for line in inf:
                # Remove Trace call from the initialize method
                if ( f"{base}TraceEvent(" in line and f"{base}::initialize()" in prev_line ):
                    pass
                
                # Keep the current line...
                else:
                    outf.write( line )
                    if ( line.find( '#include "{}"'.format(oldfsm) ) != -1):
                        outf.write( '#include "{}{}"\n'.format(path, new_trace_headerfile) )
                        

                    # Add trace for transitioned TO state (but skip the initialize() method because trace + statically created instance DON'T mix)    
                    elif ( line.find( newstate ) != -1 ):
                        newcount += 1
                        if ( newcount > 1 ):
                            outf.write( '    CPL_SYSTEM_TRACE_MSG( SECT_, ( "  New State=%s", getNameByState(getInnermostActiveState()) ));\n' )
                prev_line = line
    os.remove( cppfile )
    os.rename( tmpfile, cppfile )

    # add CPL trace hooks
    tmpfile  = old_trace_headerfile + ".tmp"
    path     = path_namespaces( namespaces )
    trace_fn = 'TraceEvent(int evt);'
    enum     = 'enum ' + base + 'TraceEvent'
    comment  = '/* Simulation which'
    
    with open( old_trace_headerfile ) as inf:
        with open( tmpfile, "w") as outf:  
            for line in inf:
                if ( line.find( '#define' ) != -1):
                    outf.write( line )
                    outf.write( '\n' )
                    outf.write( '#include "Cpl/System/Trace.h"\n' )
                    outf.write( '\n' )
                    outf.write( '/// Trace Section\n' )
                    outf.write( '#define SECT_ "{}::{}"\n'.format( "::".join(namespaces), base ) )
                    outf.write( '\n' )
                elif ( line.find( trace_fn ) != -1 ):
                    outf.write( '#define {}TraceEvent(a) CPL_SYSTEM_TRACE_MSG( SECT_, ( "  Old State=%s, Event=%s", getNameByState(getInnermostActiveState()), {}TraceEvents[a] ));\n'.format( base, base) )
                elif ( line.find( enum ) != -1 ):
                    pass
                elif ( line.find( comment ) != -1 ):
                    pass
                else:
                    outf.write( line )
                
    os.remove( old_trace_headerfile )
    os.rename( tmpfile, old_trace_headerfile )
     
     
     
#------------------------------------------------------------------------------
def getContextMethods( fname ):
    actions = []
    guards  = []
    with open(fname) as f:
        for line in f:
            g = re.search(r'[a-zA-Z0-9]+\(\)(?!\;)',line)
            a = re.search(r'[a-zA-Z0-9]+\(\)\;', line)
            if ( g != None ):
                guards.append( g.group(0) )
            if ( a != None ):
                actions.append( a.group(0).split(';')[0] )
    
    # Remove any duplicates from the grep'd methods
    return sorted(list(set(actions))), sorted(list(set(guards)))

def path_namespaces( namespaces ):
    flat = ''
    for n in namespaces:
        flat += n + "/"

    return flat

def flatten_namespaces( namespaces ):
    flat = ""
    for n in namespaces:
        flat += n + "_"

    return flat

def nested_namespaces( namespaces ):
    nest = ""
    for n in namespaces:
        nest += "namespace {} {} ".format(n,'{')

    return nest
    
def end_nested_namespaces( namespaces ):
    nest = ""
    for n in namespaces:
        nest += "};"
    nest += "  /// end namespace(s)"
    return nest

def cfg_namespaces( namespaces ):
    nest  = "*"
    for n in namespaces:
        if ( nest == "*" ):
            nest = n + " " 
        else:
            nest += "{} namespace {} ".format('{',n)

    return nest
    
def end_cfg_namespaces( namespaces ):
    nest  = ""
    count = len(namespaces)
    if ( count > 1 ):
        for n in range(1,count):
            nest += "};"
    
    return nest
    

def generatedContextClass( class_name, namespaces,  header, actions, guards ):
    fname = class_name + '.h'
    flat  = flatten_namespaces(namespaces)
    with open(fname,"w") as f:
        f.write( "#ifndef {}{}x_h_\n".format( flat, class_name ) )
        f.write( "#define {}{}x_h_\n".format( flat, class_name ) )
        f.write( header )
        f.write( "\n\n/* This file is auto-generated DO NOT MANUALLY EDIT this file! */\n\n" )
        f.write( "\n" )
        f.write( "/// Namespace(s)\n" )
        f.write( "{}\n".format( nested_namespaces(namespaces) ) )
        f.write( "\n\n" )
        f.write( "/// Context (aka actions/guards) for my Finite State Machine\n" )
        f.write( "class {}\n".format( class_name ) )
        f.write( "{\n" )
        f.write( "public:\n" )
        for a in actions:
            f.write( "    /// Action\n" )
            f.write( "    virtual void {} noexcept = 0;\n".format( a ) )
            f.write( "\n" )
        f.write( "\n" )
        f.write( "public:\n" )
        for g in guards:
            f.write( "    /// Guard\n" )
            f.write( "    virtual bool {} noexcept = 0;\n".format( g ) )
            f.write( "\n" )
        f.write( "\n" )
        f.write( "public:\n" )
        f.write( "    /// Virtual Destructor\n" )
        f.write( "    virtual ~{}(){}{}\n".format( class_name, "{","}" ) )
        f.write( "\n" )
        f.write( "};\n" )
        f.write( "\n" )
        f.write( "{}\n".format( end_nested_namespaces(namespaces) ) )
        f.write( "#endif /// end header latch\n" )
         
    
def generateEventClass( class_name, namespaces,  parent_class, parent_header, depth ):
    fname     = class_name + '.h'
    flat      = flatten_namespaces(namespaces)
    path      = path_namespaces( namespaces )
    macroname = parent_class.upper()
    
    with open(fname,"w") as f:
        f.write( "#ifndef {}{}x_h_\n".format( flat, class_name ) )
        f.write( "#define {}{}x_h_\n".format( flat, class_name ) )
        f.write( getHeader() )
        f.write( "\n\n/* This file is auto-generated DO NOT MANUALLY EDIT this file! */\n\n" )
        f.write( "\n" )
        f.write( '#include "{}{}"\n'.format(path, parent_header) )
        f.write( '#include "Cpl/Container/RingBuffer.h"\n' )
        f.write( "\n\n" )
        f.write( "/// Namespace(s)\n" )
        f.write( "{}\n".format( nested_namespaces(namespaces) ) )
        f.write( "\n\n" )
        f.write( "/// Event Queue for FSM events.\n" )
        f.write( "class {}: public {}, public Cpl::Container::RingBuffer<{}_EVENT_T>\n".format( class_name, parent_class, macroname ) )
        f.write( "{\n" )
        f.write( "protected:\n" )
        f.write( "    /// Memory for Event queue\n" )
        f.write( "    {}_EVENT_T m_eventQueMemory[{}];\n".format( macroname, depth) )
        f.write( "\n")
        f.write( "    /// Flag for tracking re-entrant events\n" )
        f.write( "    bool        m_processingFsmEvent;\n" )
        f.write( "\n")
        f.write( "public:\n" )
        f.write( "    /// Constructor\n" )
        f.write( "    {}();\n".format( class_name) )
        f.write( "\n")
        f.write( "public:\n" )
        f.write( "    /// This method properly queues and process event messages\n" )
        f.write( "    virtual void generateEvent( {}_EVENT_T msg );\n".format( macroname ) )
        f.write( "};\n" )
        f.write( "\n" )
        f.write( "{}\n".format( end_nested_namespaces(namespaces) ) )
        f.write( "#endif /// end header latch\n" )

    fname = class_name + '.cpp'
    flat  = flatten_namespaces(namespaces)
    with open(fname,"w") as f:
        f.write( getHeader() )
        f.write( "\n\n/* This file is auto-generated DO NOT MANUALLY EDIT this file! */\n\n" )
        f.write( "\n" )
        f.write( '#include "{}.h"\n'.format( class_name ) )
        f.write( '#include "Cpl/System/FatalError.h"\n' )
        f.write( '#include "Cpl/System/Trace.h"\n' )
        f.write( "\n" )
        f.write( '#define SECT_ "{}::{}"\n'.format( "::".join(namespaces), parent_class ) )
        f.write( "\n" )
        f.write( "/// Namespace(s)\n" )
        f.write( "{}\n".format( nested_namespaces(namespaces) ) )
        f.write( "\n\n" )
        f.write( "{}::{}()\n".format( class_name, class_name ) )
        f.write( ":Cpl::Container::RingBuffer<{}_EVENT_T>( {}, m_eventQueMemory )\n".format( macroname, depth ) )
        f.write( ",m_processingFsmEvent(false)\n" )
        f.write( "    {\n" ) 
        f.write( "    }\n" ) 
        f.write( "\n\n" )
        f.write( "void {}::generateEvent( {}_EVENT_T msg )\n".format( class_name, macroname ) )
        f.write( "    {\n" ) 
        f.write( "    // Queue my event\n" )
        f.write( "    if ( !add( msg ) )\n" )
        f.write( "        {\n" )
        f.write( '        Cpl::System::FatalError::logf( "{}::{}: - Buffer Overflow!" );\n'.format( "::".join(namespaces), class_name ) )
        f.write( "        }\n" )
        f.write( "\n" )
        f.write( "    // Protect against in-thread 'feedback loops' that can potentially generate events\n" )
        f.write( "    if ( !m_processingFsmEvent )\n" )
        f.write( "        {\n" )
        f.write( "        m_processingFsmEvent = true;\n" )
        f.write( "        while( remove( msg ) )\n" )
        f.write( "            {\n" )
        f.write( '            CPL_SYSTEM_TRACE_MSG( SECT_, ("Processing event:= %s, current state=%s ...", getNameByEvent(msg), getNameByState(getInnermostActiveState())) );\n' )
        f.write( "            if ( processEvent(msg) == 0 )\n" )
        f.write( "                {\n" )
        f.write( '                CPL_SYSTEM_TRACE_MSG( SECT_, ("  Event IGNORED:= %s", getNameByEvent(msg)) );\n' )
        f.write( "                }\n" )
        f.write( '            CPL_SYSTEM_TRACE_MSG( SECT_, ("  Event Completed:=  %s, end state=%s", getNameByEvent(msg), getNameByState(getInnermostActiveState())) );\n' )
        f.write( "            }\n" )
        f.write( "\n" )
        f.write( "        m_processingFsmEvent = false;\n" )
        f.write( "        }\n" )
        f.write( "    }\n" ) 
        f.write( "\n" )
        f.write( "{}\n".format( end_nested_namespaces(namespaces) ) )



#------------------------------------------------------------------------------
def geneatedCodegenConfig( fname, base, names ):
    cfg = '''# Output configuration options for the given language. Pipe them into a file for further use!
#
#Allows to define naming conventions for events
PrefixEvents=
#
#Allows to define naming conventions for simple states
PrefixSimpleStates=
#
#Allows to define naming conventions for composite states
PrefixCompositeStates=
#
#Allows to define naming conventions for choice states
PrefixChoice=

#
#Path to 'dot.exe'.
#DotPath="C:\\Program Files\\Graphviz2.22\\bin\\dot.exe"
#DotPath=/usr/local/bin/dot
DotPath=
#
#Port the graphical statediagram.simulator listens for event strings. 
UdpPort=4445
#
#Options 'yes' and 'no' are possible. If set to 'yes' only hot transitions are shown
ShowOnlyHotTransitions=no
#
#It is possible to limit the length of the event text. This keeps the image compact.
NumberOfTransitionChars=32
#
#If set to 'yes' only correct models can be saved.
SaveCheckedOnly=yes
#
#If set to 'yes' action code is displayed in the state diagram of the integrated statediagram.editor.
DisplayEntryExitDoCode=yes
#
#Limit action code in the integrated statediagram.editor to the given number of chars.
NumberOfEntryExitDoCodeChars=32
#
#

#Defines the text each generated file starts with.
Copyright=$$HEADER$$
#
#Defines if real tabs or spaces are used for indentation.
Realtab=no
#
#If realtab is 'no' this key defines how many spaces to use per tab
Tabsize=4
#
#Some systems can use special compiler keywords to place the debug strings in program memory or a specifc segment
TypeOfDbgString=const char
#
#If set to 'no' the data and time info is supressed in each file header
IncludeDateFileHeaders=no

#
#Optional namespace used in the generated C#, Java and C++ file.
Namespace=$$NAMESPACE_START$$
NamespaceEnd=$$NAMESPACE_END$$
#
#Define a base classes for the generated machine class.
BaseClassMachine=$$BASE$$

#
#Define an optional base classes for the generated state classes.
BaseClassStates=
#
#If set to yes virtual create methods are gen- erated in the factory class.
CreateFactoryMethodsVirtual=No
#
#If set to yes all state classes are generated into a single cpp/h file.
CreateOneCppStateHeaderFileOnly=Yes
#
#If set to 'yes' a destructor for the state mchine class is generated. If set to 'virtual' a virtual destructor is generated. If set to 'no' no destructor is generated.
StateMachineClassHasDestructor=no
#
#If set to 'yes' separte state classes are used. Otherwise action code is completely inlined into the state machine code
SeparateStateClasses=no
#
'''
    # Replace tokens
    cfg = cfg.replace( "$$BASE$$", base )
    cfg = cfg.replace( "$$HEADER$$", getHeaderCfg() )
    cfg = cfg.replace( "$$NAMESPACE_START$$", cfg_namespaces(names) )
    cfg = cfg.replace( "$$NAMESPACE_END$$",   end_cfg_namespaces(names) )
    
    # create file
    with open(fname,"w") as f:
        f.write( cfg )

    

#------------------------------------------------------------------------------
def getHeader():
    return  '/*-----------------------------------------------------------------------------\n' + copyright_header + '\n*----------------------------------------------------------------------------*/\n/** @file */\n\n'

def getHeaderCfg():
    text = copyright_header.replace('\n', r'\n')
    return r'/*-----------------------------------------------------------------------------\n' + text + r'\n*----------------------------------------------------------------------------*/\n/** @file */\n\n'

