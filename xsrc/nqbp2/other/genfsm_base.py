#!/usr/bin/python3
#=============================================================================
# Helper script (that does most of work) for generating FSM source code from
# Cadifra FSM diagrams
#
# This script runs the 'sinelaboreRT' Finite State Machine Code Generator
# utility.  The SinelaboreRT tool is proprietary tool, but the output of
# the code generator is NOT.  This script is also specific to parsing
# FSM diagramS generated by the Cadifra drawing tool (yet another 
# proprietary tool).  Yes - using non open source tools is straying from
# the pure faith - but both tools are very good and affordable - and the
# generated source code and diagram content is still 'free'.
#
# http://www.sinelabore.com/
# http://www.cadifra.com/
#
#=============================================================================

#
import sys   
import os
import subprocess
#
from nqbplib.docopt.docopt import docopt
from nqbplib import utils

# 
usage = """ 
genfsm - Generates source code from Cadifra FSM Diagrams (.cdd files)
===============================================================================
Usage: genfsm [options] <basename> <namespaces> [<sinelabore>...]

Arguments:
  <basename>       Base name for the FSM.  The Cadifra diagram must have this
                   same file name.  All generated output files will have the 
                   <basename> as part of their file names. <basename> IS 
                   case sensitive!
      
  <namespaces>     The encapsulated namespace(s) for the generated files. The
                   Format is: 'Rte::Db::Record'
                   
  <sinelabore>     Optional arguments passed directly to the Sinelabore code
                   generator

Options:
  -d NEVENTS       When NEVENTS is greater then 0 code for an event queue is 
                   generated where NEVENTS is the size of the event queue. 
                   [Default: 0]
  -h, --help       Display command help.
        
         
NOTES:
    o The environment variable SINELABORE_PATH is required/used to specify
      the location of the Sinelabore code generator JAR files (and it 
      supporting JAR files).
    o The script assumes that Graphviz's dot.exe is in the command path.
      GraphViz is used to generated the FSM diagram for Doxygen. See 
      http://www.graphviz.org
      
"""

copyright_header = """* This file is part of the Colony.Core Project.  The Colony.Core Project is an
* open source project with a BSD type of licensing agreement.  See the license
* agreement (license.txt) in the top/ directory or on the Internet at
* http://integerfox.com/colony.core/license.txt
*
* Copyright (c) 2014-2020  John T. Taylor
*
* Redistributions of the source code must retain the above copyright notice."""

#
import subprocess
import re
import sys

#------------------------------------------------------------------------------
# Parse command line
def run( argv, copyright=None ):
    global copyright_header

    # Process command line args...
    args  = docopt(usage, version="0.0.1", options_first=True )
    sargs = ' '.join( args['<sinelabore>'] )

    # Check the environment variables 
    sinpath = os.environ.get( "SINELABORE_PATH" )
    if ( sinpath == None ):
        exit( "ERROR: The SINELABORE_PATH environment variable is not set." )
    
    # Set copyright header (if specified)
    if ( copyright != None ):
        copyright_header = copyright

    # Convert namespace arg to list
    names = args['<namespaces>'].split('::')
    
    # Filenames
    fsmdiag = args['<basename>'] + ".cdd"
    base    = args['<basename>'] + "Context_" 
    evque   = args['<basename>'] + "EventQueue_" 
    fsm     = args['<basename>'] 
    cfg     = 'codegen.cfg'
      
    # Generated File names
    oldfsm      = fsm + '.h'
    oldfsmcpp   = fsm + '.cpp'
    oldevt      = fsm + '_ext.h'
    oldtrace    = fsm + '_trace.h'
    oldtracecpp = fsm + '_trace.cpp'
    oldtrace2   = fsm + '_trace.java'
    newfsm      = fsm + '_.h'
    newfsmcpp   = fsm + '_.cpp'
    newevt      = fsm + '_ext_.h'
    newtrace    = fsm + '_trace_.h'
    
    # Delete 'optional' old/previous files 
    utils.delete_file( evque + ".h" )
    utils.delete_file( evque + ".cpp" )
    
    # Create the config file for Sinelabore
    geneatedCodegenConfig( cfg, base, names )
        
    # Build Sinelabore command
    cmd = 'java -cp {}\*; codegen.Main {} -p CADIFRA -doxygen -o {} -l cppx -Trace {}'.format( sinpath, sargs, fsm, fsmdiag )
    cmd = utils.standardize_dir_sep( cmd )
  
    # Invoke Sinelabore command
    print(cmd)
    p = subprocess.Popen( cmd, shell=True )
    r = p.communicate()
    if ( p.returncode != 0 ):
        exit("ERROR: Sinelabore encounterd an error or failed to run." )
    
    # Clean-up config file (don't want it being checked into version control)
    os.remove( cfg )
    
    # Mangle the event names so that I can have many FSMs in the same namespace with the same event names
    eventList = get_events_names( oldevt )
    mangle_event_names( oldevt, eventList, fsm, ' ' )
    mangle_event_names( oldfsmcpp, eventList, fsm, '"', '0', '=' )
    mangle_event_names( oldtrace, eventList, fsm, '"' )
    cleanup_global_define( oldevt, fsm, names )

    # Generate Context/Base class
    actions, guards = getContextMethods( fsmdiag )
    generatedContextClass( base, names, getHeader(), actions, guards )
    
    # Generated event queuue class
    depth = args['-d'].strip()  
    if ( depth != '0' ):
        generateEventClass( evque, names, fsm, newfsm, depth )
        
    # Post process the generated file(s) to work better with Doxygen
    cleanup_for_doxygen( fsm + ".h", args['<namespaces>'] + "::" + fsm )
    cleanup_for_doxygen( oldtrace )
    cleanup_for_doxygen( oldevt )
      
    
    # Post process the generated file(s) 
    cleanup_trace( oldfsmcpp, names, fsm, oldfsm, oldtrace, newtrace, oldtracecpp )
    cleanup_includes( oldfsm,    names, oldfsm, newfsm, oldevt, newevt, base + '.h' )
    cleanup_includes( oldfsmcpp, names, oldfsm, newfsm, oldevt, newevt, base + '.h' )
    convert_member_to_class_methods_header( oldfsm, fsm )  
    convert_member_to_class_methods_cpp( oldfsmcpp, fsm )  

    # Housekeeping for naming convention
    utils.delete_file( newfsm )
    utils.delete_file( newfsmcpp )
    utils.delete_file( newevt )
    utils.delete_file( newtrace )
    utils.delete_file( oldtrace2 )      # remove unwanted JAVA file
    utils.delete_file( oldtracecpp )    # remove unused CPP file
    os.rename( oldfsm, newfsm )
    os.rename( oldfsmcpp, newfsmcpp ) 
    os.rename( oldevt, newevt ) 
    os.rename( oldtrace, newtrace ) 



#------------------------------------------------------------------------------
def get_events_names( ext_header_file ):
    found_start = False
    events      = []
    with open( ext_header_file ) as inf:
        for line in inf:
            line = line.lstrip()

            # Capture events
            if ( found_start ):
                if ( line.find("_NO_MSG") == -1 ):
                    event = line.strip().split('=')[0]
                    event = event.strip().split(',')[0]
                    events.append( event.strip() )

                # All events found -->can exit the function
                else:
                    break;

            # Find the start of the events                    
            if ( line.startswith( "enum" ) ):
                found_start = True

    # Return found events
    return events  

#
def mangle_event_names( file, events, prefix, pre_del1, pre_del2=None, pre_del3=None ):
    tmpfile       = file + ".tmp"
    found_indexes = False    
    with open( file ) as inf:
        with open( tmpfile, "w") as outf:  
            for line in inf:

                # Replace event names
                for e in events:
                    # Brute force approach to replacing whole event names (i.e. properly handle evStop & evStopped)
                    old_ev = pre_del1 + e
                    new_ev = pre_del1 + prefix + "_" + e
                    line   = line.replace(old_ev,new_ev,1)
                    if ( pre_del2 != None ):
                        old_ev = pre_del2 + e
                        new_ev = pre_del2 + prefix + "_" + e
                        line   = line.replace(old_ev,new_ev,1)
                        if ( pre_del3 != None ):
                            old_ev = pre_del3 + e
                            new_ev = pre_del3 + prefix + "_" + e
                            line   = line.replace(old_ev,new_ev,1)
                    
                # Fix event name indexes
                if ( found_indexes ):
                    line = fix_indexes( line, prefix );
                    found_indexes = False
                elif ( line.find( "const unsigned short evt_idx[]={" ) != -1 ):
                    found_indexes = True
                         
                outf.write( line )
    
    os.remove( file )
    os.rename( tmpfile, file )


# 
def fix_indexes( line, prefix ):
    line       = line.replace('};','').strip()
    k          = len(prefix) + 1
    offsets    = line.strip().split(",")
    idx        = 0
    newoffsets = []
    
    # Strip off potential trailing ',' (e.g. happens when there are no 'true' events)
    if ( offsets[len(offsets)-1] == '' ):
        del offsets[len(offsets)-1]

    for i in offsets:
        n      = int(i)
        newidx = n + idx * k
        idx   += 1
        newoffsets.append( str(newidx) )
        
    newline  = "        " + ','.join(newoffsets) + '};\n'
    return newline
        
    
#
def cleanup_for_doxygen( headerfile, classname='<not-used>' ):
    tmpfile = headerfile + ".tmp"
    skip_state = 0
    with open( headerfile ) as inf:
        with open( tmpfile, "w") as outf:  
            for line in inf:
                if ( line.startswith( "namespace") and skip_state == 0 ):
                    outf.write( "#ifndef DOXYGEN_WILL_SKIP_THIS\n\n");
                    outf.write( line );
                    skip_state += 1
                    continue
                if ( line.startswith( "#endif") and skip_state == 1):
                    outf.write( "#endif // !DOXYGEN_WILL_SKIP_THIS\n\n");
                    outf.write( line );
                    skip_state += 1
                    continue

                if ( line.find( 'Here is the graph that shows the state machine' ) == -1 ):
                    outf.write( line )
                else:
                    outf.write( "/** \class {}\n\nHere is the graph that shows the state machine this class implements\n\n\dot\n".format( classname ) )
    
    os.remove( headerfile )
    os.rename( tmpfile, headerfile )
 
#
def cleanup_global_define( headerfile, fsm_name, namespaces ):
    tmpfile = headerfile + ".tmp"
    skip_state = 0
    with open( headerfile ) as inf:
        with open( tmpfile, "w") as outf:  
            for line in inf:

                if ( line.startswith( '#define InnermostStates ' )-1 ):
                    outf.write( line )
                else:
                    tokens = line.split()
                    outf.write( '#define {}{}_InnermostStates {};\n'.format(flatten_namespaces(namespaces), fsm_name, tokens[2]))
    
    os.remove( headerfile )
    os.rename( tmpfile, headerfile )
                     

#
def cleanup_includes( headerfile, namespaces, oldfsm, newfsm, oldevt, newevt, base ):
    tmpfile = headerfile + ".tmp"
    path    = path_namespaces( namespaces )
    
    with open( headerfile ) as inf:
        with open( tmpfile, "w") as outf:  
            for line in inf:
                if ( line.find( '#include "{}"'.format(oldfsm) ) != -1):
                    outf.write( '#include "{}{}"\n'.format(path, newfsm) )
                elif ( line.find( '#include "{}"'.format(oldevt) ) != -1) :
                    outf.write( '#include "{}{}"\n'.format(path, newevt) )
                elif ( line.find( '#include "{}"'.format(base) ) != -1) :
                    outf.write( '#include "{}{}"\n'.format(path, base) )
                else:
                    outf.write( line )
    
    os.remove( headerfile )
    os.rename( tmpfile, headerfile )

#
def convert_member_to_class_methods_header( file, parent_class ):
    macroname = parent_class.upper()
    tmpfile  = file + ".tmp"
    with open( file ) as inf:
        with open( tmpfile, "w") as outf:  
            for line in inf:
                if ( "const char* getNameByState(const unsigned short state) const" in line ):
                    line = line.replace("const char* getNameByState(const unsigned short state) const","static const char* getNameByState(const unsigned short state)" )
                if ( f"const char* getNameByEvent(const {macroname}_EVENT_T evt) const" in line ):
                    line = line.replace(f"const char* getNameByEvent(const {macroname}_EVENT_T evt) const", f"static const char* getNameByEvent(const {macroname}_EVENT_T evt)" )
                outf.write( line )
    os.remove( file )
    os.rename( tmpfile, file )

def convert_member_to_class_methods_cpp( file, parent_class ):
    macroname = parent_class.upper()
    tmpfile  = file + ".tmp"
    with open( file ) as inf:
        with open( tmpfile, "w") as outf:  
            for line in inf:
                if ( f"const char* {parent_class}::getNameByState(const unsigned short state) const" in line ):
                    line = line.replace(f"const char* {parent_class}::getNameByState(const unsigned short state) const",f"const char* {parent_class}::getNameByState(const unsigned short state)" )
                if ( f"const char* {parent_class}::getNameByEvent(const {macroname}_EVENT_T evt) const" in line ):
                    line = line.replace(f"const char* {parent_class}::getNameByEvent(const {macroname}_EVENT_T evt) const", f"const char* {parent_class}::getNameByEvent(const {macroname}_EVENT_T evt)" )
                outf.write( line )
    os.remove( file )
    os.rename( tmpfile, file )
                
      
#      
def cleanup_trace( cppfile, namespaces, base, oldfsm, old_trace_headerfile, new_trace_headerfile, oldtracecpp ):
    # Add xx_trace_.h include to xxx_.cpp
    tmpfile  = cppfile + ".tmp"
    path     = path_namespaces( namespaces )
    newstate = 'stateVars = stateVarsCopy;'
    newcount = 0
    
    # Update the state machine .cpp file with Tracing tweaks
    prev_line = ''
    with open( cppfile ) as inf:
        with open( tmpfile, "w") as outf:  
            for line in inf:
                # Remove Trace call from the initialize method
                if ( f"{base}TraceEvent(" in line and f"{base}::initialize()" in prev_line ):
                    pass
                
                # Keep the current line...
                else:
                    outf.write( line )
                    if ( line.find( '#include "{}"'.format(oldfsm) ) != -1):
                        outf.write( '#include "{}{}"\n'.format(path, new_trace_headerfile) )
                        

                    # Add trace for transitioned TO state (but skip the initialize() method because trace + statically created instance DON'T mix)    
                    elif ( line.find( newstate ) != -1 ):
                        newcount += 1
                        if ( newcount > 1 ):
                            outf.write( '    CPL_SYSTEM_TRACE_MSG( SECT_, ( "  New State=%s", getNameByState(getInnermostActiveState()) ));\n' )
                prev_line = line
                
    os.remove( cppfile )
    os.rename( tmpfile, cppfile )

    # Get event array from trace.cpp
    events = ''
    found  = False
    with open( oldtracecpp, "r") as inf:  
        for line in inf:
            if ( line.find("const") != -1 or found == True ):
                events = events + line
                found  = True
                if ( line.find(';') != -1 ):
                    found = False


    # add CPL trace hooks
    tmpfile  = old_trace_headerfile + ".tmp"
    trace_fn = 'TraceEvent('
    
    added_include = False
    with open( old_trace_headerfile ) as inf:
        with open( tmpfile, "w") as outf:  
            for line in inf:
                if ( line.find( '#define' ) != -1 and added_include == False ):
                    added_include = True
                    outf.write( line )
                    outf.write( '\n' )
                    outf.write( '#include "Cpl/System/Trace.h"\n' )
                    outf.write( '\n' )
                    outf.write( '/// Trace Section\n' )
                    outf.write( '#define SECT_ "{}::{}"\n'.format( "::".join(namespaces), base ) )
                    outf.write( '\n' )
                elif ( line.find( trace_fn ) != -1 ):
                    outf.write( '#define {}TraceEvent(a) CPL_SYSTEM_TRACE_MSG( SECT_, ( "  Old State=%s, Event=%s", getNameByState(getInnermostActiveState()), {}TraceEvents[a] ));\n'.format( base, base) )
                    outf.write('\n')        
                    outf.write( events )
                else:
                    outf.write( line )


    os.remove( old_trace_headerfile )
    os.rename( tmpfile, old_trace_headerfile )
     
     
     
#------------------------------------------------------------------------------
def getContextMethods( fname ):
    actions = []
    guards  = []
    with open(fname) as f:
        for line in f:
            guard_matches = re.findall(r'[^a-zA-Z0-9_]([a-zA-Z0-9]+\(\))(?!\;)',line)
            a = re.search(r'[a-zA-Z0-9]+\(\)\;', line)
            if ( guard_matches != None ):
                guards.extend( guard_matches )
            if ( a != None ):
                actions.append( a.group(0).split(';')[0] )
    
    # Remove any duplicates from the grep'd methods
    return sorted(list(set(actions))), sorted(list(set(guards)))

def path_namespaces( namespaces ):
    flat = ''
    for n in namespaces:
        flat += n + "/"

    return flat

def flatten_namespaces( namespaces ):
    flat = ""
    for n in namespaces:
        flat += n + "_"

    return flat

def nested_namespaces( namespaces ):
    nest = ""
    for n in namespaces:
        nest += "namespace {} {} ".format(n,'{')

    return nest
    
def end_nested_namespaces( namespaces ):
    nest = ""
    for n in namespaces:
        nest += "};"
    nest += "  // end namespace(s)"
    return nest

def cfg_namespaces( namespaces ):
    nest  = "*"
    for n in namespaces:
        if ( nest == "*" ):
            nest = n + " " 
        else:
            nest += "{} namespace {} ".format('{',n)

    return nest
    
def end_cfg_namespaces( namespaces ):
    nest  = ""
    count = len(namespaces)
    if ( count > 1 ):
        for n in range(1,count):
            nest += "};"
    
    return nest
    

def generatedContextClass( class_name, namespaces,  header, actions, guards ):
    fname = class_name + '.h'
    flat  = flatten_namespaces(namespaces)
    with open(fname,"w") as f:
        f.write( "#ifndef {}{}x_h_\n".format( flat, class_name ) )
        f.write( "#define {}{}x_h_\n".format( flat, class_name ) )
        f.write( header )
        f.write( "\n\n/* This file is auto-generated DO NOT MANUALLY EDIT this file! */\n\n" )
        f.write( "\n" )
        f.write( "///\n" )
        f.write( "{}\n".format( nested_namespaces(namespaces) ) )
        f.write( "\n\n" )
        f.write( "/// Context (aka actions/guards) for my Finite State Machine\n" )
        f.write( "class {}\n".format( class_name ) )
        f.write( "{\n" )
        f.write( "public:\n" )
        for a in actions:
            f.write( "    /// Action\n" )
            f.write( "    virtual void {} noexcept = 0;\n".format( a ) )
            f.write( "\n" )
        f.write( "\n" )
        f.write( "public:\n" )
        for g in guards:
            f.write( "    /// Guard\n" )
            f.write( "    virtual bool {} noexcept = 0;\n".format( g ) )
            f.write( "\n" )
        f.write( "\n" )
        f.write( "public:\n" )
        f.write( "    /// Virtual Destructor\n" )
        f.write( "    virtual ~{}(){}{}\n".format( class_name, "{","}" ) )
        f.write( "\n" )
        f.write( "};\n" )
        f.write( "\n" )
        f.write( "{}\n".format( end_nested_namespaces(namespaces) ) )
        f.write( "#endif /// end header latch\n" )
         
    
def generateEventClass( class_name, namespaces,  parent_class, parent_header, depth ):
    fname     = class_name + '.h'
    flat      = flatten_namespaces(namespaces)
    path      = path_namespaces( namespaces )
    macroname = parent_class.upper()
    
    with open(fname,"w") as f:
        f.write( "#ifndef {}{}x_h_\n".format( flat, class_name ) )
        f.write( "#define {}{}x_h_\n".format( flat, class_name ) )
        f.write( getHeader() )
        f.write( "\n\n/* This file is auto-generated DO NOT MANUALLY EDIT this file! */\n\n" )
        f.write( "\n" )
        f.write( '#include "{}{}"\n'.format(path, parent_header) )
        f.write( '#include "Cpl/Container/RingBuffer.h"\n' )
        f.write( "\n\n" )
        f.write( "///\n" )
        f.write( "{}\n".format( nested_namespaces(namespaces) ) )
        f.write( "\n\n" )
        f.write( "/// Event Queue for FSM events.\n" )
        f.write( "class {}: public {}, public Cpl::Container::RingBuffer<{}_EVENT_T>\n".format( class_name, parent_class, macroname ) )
        f.write( "{\n" )
        f.write( "public:\n" );
        f.write( "    /// Define callback function that is called when an event has completed\n" )
        f.write( "    typedef void ( *EventCompletedCbFunc_T )( {}_EVENT_T proceessedMsg );\n".format( macroname ) )
        f.write( "\n" )
        f.write( "protected:\n" )
        f.write( "    /// Optional Callback function for event-completed (typically used for unit testing purposes)\n" )
        f.write( "    EventCompletedCbFunc_T  m_eventCompletedCallback;\n" )
        f.write( "\n" )
        f.write( "    /// Memory for Event queue\n" )
        f.write( "    {}_EVENT_T m_eventQueMemory[{}];\n".format( macroname, depth) )
        f.write( "\n")
        f.write( "    /// Flag for tracking re-entrant events\n" )
        f.write( "    bool        m_processingFsmEvent;\n" )
        f.write( "\n")
        f.write( "public:\n" )
        f.write( "    /// Constructor\n" )
        f.write( "    {}( EventCompletedCbFunc_T eventCompletedCallback = nullptr );\n".format( class_name) )
        f.write( "\n")
        f.write( "public:\n" )
        f.write( "    /// This method properly queues and process event messages\n" )
        f.write( "    virtual void generateEvent( {}_EVENT_T msg );\n".format( macroname ) )
        f.write( "};\n" )
        f.write( "\n" )
        f.write( "{}\n".format( end_nested_namespaces(namespaces) ) )
        f.write( "#endif /// end header latch\n" )

    fname = class_name + '.cpp'
    flat  = flatten_namespaces(namespaces)
    with open(fname,"w") as f:
        f.write( getHeader() )
        f.write( "\n\n/* This file is auto-generated DO NOT MANUALLY EDIT this file! */\n\n" )
        f.write( "\n" )
        f.write( '#include "{}.h"\n'.format( class_name ) )
        f.write( '#include "Cpl/System/FatalError.h"\n' )
        f.write( '#include "Cpl/System/Trace.h"\n' )
        f.write( "\n" )
        f.write( '#define SECT_ "{}::{}"\n'.format( "::".join(namespaces), parent_class ) )
        f.write( "\n" )
        f.write( "///\n" )
        f.write( "{}\n".format( nested_namespaces(namespaces) ) )
        f.write( "\n\n" )
        f.write( "{}::{}( EventCompletedCbFunc_T eventCompletedCallback )\n".format( class_name, class_name ) )
        f.write( ": Cpl::Container::RingBuffer<{}_EVENT_T>( {}, m_eventQueMemory )\n".format( macroname, depth ) )
        f.write( ", m_eventCompletedCallback( eventCompletedCallback )\n" )
        f.write( ", m_processingFsmEvent(false)\n" )
        f.write( "    {\n" ) 
        f.write( "    }\n" ) 
        f.write( "\n\n" )
        f.write( "void {}::generateEvent( {}_EVENT_T msg )\n".format( class_name, macroname ) )
        f.write( "    {\n" ) 
        f.write( "    // Queue my event\n" )
        f.write( "    if ( !add( msg ) )\n" )
        f.write( "        {\n" )
        f.write( '        Cpl::System::FatalError::logf( "{}::{}: - Buffer Overflow!" );\n'.format( "::".join(namespaces), class_name ) )
        f.write( "        }\n" )
        f.write( "\n" )
        f.write( "    // Protect against in-thread 'feedback loops' that can potentially generate events\n" )
        f.write( "    if ( !m_processingFsmEvent )\n" )
        f.write( "        {\n" )
        f.write( "        m_processingFsmEvent = true;\n" )
        f.write( "        while( remove( msg ) )\n" )
        f.write( "            {\n" )
        f.write( '            CPL_SYSTEM_TRACE_MSG( SECT_, ("Processing event:= %s, current state=%s ...", getNameByEvent(msg), getNameByState(getInnermostActiveState())) );\n' )
        f.write( "            if ( processEvent(msg) == 0 )\n" )
        f.write( "                {\n" )
        f.write( '                CPL_SYSTEM_TRACE_MSG( SECT_, ("  Event IGNORED:= %s", getNameByEvent(msg)) );\n' )
        f.write( "                }\n" )
        f.write( '            CPL_SYSTEM_TRACE_MSG( SECT_, ("  Event Completed:=  %s, end state=%s", getNameByEvent(msg), getNameByState(getInnermostActiveState())) );\n' )
        f.write( "\n" )
        f.write( "            // Provide 'hook' for event-processing-completed\n" )
        f.write( '            if ( m_eventCompletedCallback )\n' )
        f.write( '                {\n' )
        f.write( '                (m_eventCompletedCallback) ( msg );\n' )
        f.write( '                }\n' )
        f.write( "            }\n" )
        f.write( "\n" )
        f.write( "        m_processingFsmEvent = false;\n" )
        f.write( "        }\n" )
        f.write( "    }\n" ) 
        f.write( "\n" )
        f.write( "{}\n".format( end_nested_namespaces(namespaces) ) )



#------------------------------------------------------------------------------
def geneatedCodegenConfig( fname, base, names ):
    cfg = '''# Output configuration options for the given language. Pipe them into a file for further use!
#
#Allows to define naming conventions for events
PrefixEvents=
#
#Allows to define naming conventions for simple states
PrefixSimpleStates=
#
#Allows to define naming conventions for composite states
PrefixCompositeStates=
#
#Allows to define naming conventions for choice states
PrefixChoice=

#
#Path to 'dot.exe'.
#DotPath="C:\\Program Files\\Graphviz2.22\\bin\\dot.exe"
#DotPath=/usr/local/bin/dot
DotPath=
#
#Port the graphical statediagram.simulator listens for event strings. 
UdpPort=4445
#
#Options 'yes' and 'no' are possible. If set to 'yes' only hot transitions are shown
ShowOnlyHotTransitions=no
#
#It is possible to limit the length of the event text. This keeps the image compact.
NumberOfTransitionChars=32
#
#If set to 'yes' only correct models can be saved.
SaveCheckedOnly=yes
#
#If set to 'yes' action code is displayed in the state diagram of the integrated statediagram.editor.
DisplayEntryExitDoCode=yes
#
#Limit action code in the integrated statediagram.editor to the given number of chars.
NumberOfEntryExitDoCodeChars=32
#
#

#Defines the text each generated file starts with.
Copyright=$$HEADER$$
#
#Defines if real tabs or spaces are used for indentation.
Realtab=no
#
#If realtab is 'no' this key defines how many spaces to use per tab
Tabsize=4
#
#Some systems can use special compiler keywords to place the debug strings in program memory or a specifc segment
TypeOfDbgString=const char
#
#If set to 'no' the data and time info is supressed in each file header
IncludeDateFileHeaders=no

#
#Optional namespace used in the generated C#, Java and C++ file.
Namespace=$$NAMESPACE_START$$
NamespaceEnd=$$NAMESPACE_END$$
#
#Define a base classes for the generated machine class.
BaseClassMachine=$$BASE$$

#
#Define an optional base classes for the generated state classes.
BaseClassStates=
#
#If set to yes virtual create methods are gen- erated in the factory class.
CreateFactoryMethodsVirtual=No
#
#If set to yes all state classes are generated into a single cpp/h file.
CreateOneCppStateHeaderFileOnly=Yes
#
#If set to 'yes' a destructor for the state mchine class is generated. If set to 'virtual' a virtual destructor is generated. If set to 'no' no destructor is generated.
StateMachineClassHasDestructor=no
#
#If set to 'yes' separte state classes are used. Otherwise action code is completely inlined into the state machine code
SeparateStateClasses=no
#
ReturnEventProcessed=yes

'''
    # Replace tokens
    cfg = cfg.replace( "$$BASE$$", base )
    cfg = cfg.replace( "$$HEADER$$", getHeaderCfg() )
    cfg = cfg.replace( "$$NAMESPACE_START$$", cfg_namespaces(names) )
    cfg = cfg.replace( "$$NAMESPACE_END$$",   end_cfg_namespaces(names) )
    
    # create file
    with open(fname,"w") as f:
        f.write( cfg )

    

#------------------------------------------------------------------------------
def getHeader():
    return  '/*-----------------------------------------------------------------------------\n' + copyright_header + '\n*----------------------------------------------------------------------------*/\n/** @file */\n\n'

def getHeaderCfg():
    text = copyright_header.replace('\n', r'\n')
    return r'/*-----------------------------------------------------------------------------\n' + text + r'\n*----------------------------------------------------------------------------*/\n/** @file */\n\n'

